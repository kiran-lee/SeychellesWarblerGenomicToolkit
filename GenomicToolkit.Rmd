---
title: "Genomics of Inbreeding in recently bottlenecked Seychelles warblers"
author: "Kiran Gok Lune Lee"
date: "`r Sys.Date()`"
geometry: margin=2cm 
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
    fig_width: 12
    fig_height: 10
    output_file: "Kiran_Lee_Genomics_Inbreeding_Seychelles_warblers.html"
  pdf_document:
    latex_engine: xelatex
    fig_width: 8
    fig_height: 6
    output_file: "Kiran_Lee_Genomics_Inbreeding_Seychelles_warblers.pdf"
---

## Set up environment

```{r setup, include=FALSE}
library(knitr)
knitr::opts_knit$set(root.dir = "~/Documents/GitHub/SeychellesWarblerGenomicToolkit/3_Sample_verification_by_genomic_sex_and_pedigree_assignment/Data")
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	tidy = TRUE,
	tidy.opts = list(width.cutoff = 60)
)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

R.Version()
library(readr)
library(tidyverse)
library(dplyr)
library(readxl)
library(openxlsx)
library(ggplot2)
library("data.table") 
library("reshape2")
library(sequoia)
library(lmerTest)
library(ggrepel)
library(ggExtra)
library(genio)


```
## Ch.1 Map of Seychelles

Create a map for future figures.

```{r map, eval = TRUE, echo = TRUE, tidy=FALSE}


library(sf)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(ggspatial)
library(cowplot)
library(dplyr)
library(scales)
library(geodata)

# --- 1. Get Spatial Data ---

# Use GADM data for higher-resolution Seychelles boundaries
seychelles_highres_sv <- gadm(country = "SYC", level = 0, path = tempdir())
seychelles_sf <- st_as_sf(seychelles_highres_sv)

# Get world data for the inset map
world_sf <- ne_countries(scale = "medium", returnclass = "sf")

# --- Define Label Coordinates and Filter ---
all_label_coords <- data.frame(
  name = c("Mahé", "Cousin", "Cousine", "Aride", "Félicité", "Marianne", "Frégate", "Denis", "Seychelles"),
  lon = c(55.48, 55.66, 55.66, 55.67, 55.80, 55.86, 55.95, 55.67, 55.25),
  lat = c(-4.68, -4.33, -4.33, -4.13, -4.38, -4.46, -4.59, -3.80, -4.80) # Use negative for South
)

# Update the labels_to_keep vector to include the separated names
labels_to_keep <- c("Cousin", "Cousine", "Aride", "Frégate", "Denis", "Seychelles")

# Update the filtering as before
label_coords <- all_label_coords %>%
  filter(name %in% labels_to_keep)

# Define nudging values with Cousin and Cousine separated
nudge_values <- data.frame(
  name = c("Cousin", "Cousine", "Aride", "Frégate", "Denis", "Seychelles"),
  nudge_x = c(-0.05, -0.07, 0.03, 0.03, 0.03, 0), # No shift for Cousin, -0.01 left for Cousine
  nudge_y = c(-0.00, -0.04, -0.06, -0.02, 0.02, 0) # Using calculated values
)

# Create the pre-joined data frame for text labels
text_data <- label_coords %>%
  left_join(nudge_values, by="name")

# --- Define Bounding Boxes ---
# Extended north boundary to fully include Denis Island
# And shortening the bottom by 10%
lon_limits_main <- c(54.95, 56.15)
lat_bottom <- -5.1
lat_top <- -3.7
lat_range <- lat_top - lat_bottom
shortened_lat_bottom <- lat_bottom + (lat_range * 0.1) # Reduce bottom by 10%
lat_limits_main <- c(shortened_lat_bottom, lat_top)

# --- Create explicit graticules (grid lines) ---
# Create longitude lines
lon_grid <- data.frame(
  long = rep(seq(55.0, 56.0, by = 0.2), each = 2),
  lat = rep(c(min(lat_limits_main), max(lat_limits_main)), times = length(seq(55.0, 56.0, by = 0.2)))
)
lon_grid <- lon_grid %>%
  group_by(long) %>%
  mutate(group = cur_group_id())

# Create latitude lines
lat_grid <- data.frame(
  long = rep(c(min(lon_limits_main), max(lon_limits_main)), times = length(seq(-5.0, -3.8, by = 0.2))),
  lat = rep(seq(-5.0, -3.8, by = 0.2), each = 2)
)
lat_grid <- lat_grid %>%
  group_by(lat) %>%
  mutate(group = cur_group_id())

# Function for degree labels
label_degree_min <- function(x, axis = "x") {
  ifelse(
    abs(x - round(x)) < 1e-6,
    paste0(abs(round(x)), "°", "00'"),
    paste0(abs(floor(x)), "°", formatC(round((abs(x) - floor(abs(x))) * 60), width = 2, flag = "0"), "'")
  )
}

# --- 2. Create the Main Map ---
lon_limits_inset <- c(30, 85)
lat_limits_inset <- c(-15, 30)

gg_main <- ggplot() +
  # Add explicit graticules first
  geom_line(data = lon_grid, aes(x = long, y = lat, group = group), color = "grey60", linewidth = 0.3) +
  geom_line(data = lat_grid, aes(x = long, y = lat, group = group), color = "grey60", linewidth = 0.3) +
  
  # Draw land polygons
  geom_sf(data = seychelles_sf, fill = "black", color = NA) +

  # Define Coordinate System and Limits
  coord_sf(
    xlim = lon_limits_main,
    ylim = lat_limits_main,
    crs = 4326,
    expand = FALSE
  ) +

  # Add axis labels
  scale_x_continuous(
    name = "Longitude",
    breaks = seq(55.0, 56.0, by = 0.2),
    labels = function(x) label_degree_min(x, axis = "x")
  ) +
  scale_y_continuous(
    name = "Latitude",
    breaks = seq(-5.0, -3.8, by = 0.2),
    labels = function(x) label_degree_min(x, axis = "y")
  ) +

  # Add island labels using the provided geom_text code
  geom_text(
      data = text_data %>% filter(name != "Seychelles"), # Use the pre-joined data frame
      aes(x = lon, y = lat, label = name),
      # Apply row-specific nudging using position_nudge
      position = position_nudge(x = text_data$nudge_x[text_data$name != "Seychelles"], 
                                y = text_data$nudge_y[text_data$name != "Seychelles"]),
      fontface = "italic",
      size = 3.5,
      hjust = 0.5
  ) +

  # Add "Seychelles" label
  geom_text(
    data = text_data %>% filter(name == "Seychelles"),
    aes(x = lon, y = lat, label = name),
    size = 5,
    fontface = "plain"
  ) +

  # Add scale bar
  annotation_scale(
    location = "br", style = "bar", bar_cols = c("grey20", "white"),
    width_hint = 0.25, pad_x = unit(0.5, "cm"), pad_y = unit(0.5, "cm"),
    height = unit(0.15, "cm"), text_cex = 0.8
  ) +

  # Add north arrow
  annotation_north_arrow(
    location = "bl", which_north = "true",
    pad_x = unit(0.5, "cm"), pad_y = unit(0.8, "cm"),
    style = north_arrow_fancy_orienteering(fill = c("black", "white"), line_col = "black"),
    height = unit(1.0, "cm"), width = unit(1.0, "cm")
  ) +

  # Apply theme
  theme_bw(base_size = 10) +
  theme(
    panel.background = element_rect(fill = "grey90", colour = NA),
    panel.grid = element_blank(),  # Remove default grid
    panel.border = element_rect(colour = "black", fill=NA, linewidth=0.7),
    axis.text = element_text(color = "black", size = 9),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(size=10),
    plot.background = element_rect(fill = "white", colour = NA)
  )

# --- 3. Create the Inset Map ---
seychelles_lon_inset <- 55.5
seychelles_lat_inset <- -4.6

gg_inset <- ggplot() +
  geom_sf(data = world_sf, fill = "grey75", color = "white", linewidth = 0.15) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.4) +
  annotate("rect", xmin = seychelles_lon_inset - 1.5, xmax = seychelles_lon_inset + 1.5,
           ymin = seychelles_lat_inset - 1, ymax = seychelles_lat_inset + 1,
           fill = NA, color = "black", linewidth = 0.5) +
  annotate("text", x = 42, y = 10, label = "AFRICA", size = 3, fontface = "bold", hjust = 0.5) +
  annotate("text", x = 75, y = 20, label = "INDIA", size = 3, fontface = "bold", hjust = 0.5) +
  annotate("text", x = 35, y = 1, label = "EQUATOR", size = 2.5, hjust = 0, vjust = -0.5) +
  annotate("text", x = seychelles_lon_inset + 2.5, y = seychelles_lat_inset, label = "Seychelles", size = 2.5, hjust = 0) +
  coord_sf(xlim = lon_limits_inset, ylim = lat_limits_inset, crs = 4326, expand = FALSE) +
  theme_void() +
  theme(
    panel.background = element_rect(fill = "grey90", colour = NA),
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.5),
    plot.margin = margin(0,0,0,0)
  )

# --- 4. Combine Main Map and Inset Map ---
gg_final <- ggdraw(gg_main) +
  draw_plot(
    gg_inset,
    x = 0.2, y = 0.59, width = 0.35, height = 0.35
  )

# --- 5. Display the Final Map ---
print(gg_final)

#ggsave("seychelles_map_recreation_final.png", plot = gg_final, width = 8, height = 7, dpi = 300)
```
## Ch.1 SeqIDs (1st round of imputation)

Load SeqIDs of sequenced samples after first round of imputation by STITCH.

```{r seqids1, eval = TRUE, echo = FALSE, include=TRUE}
CoverageExtraSamples <- read.delim("coveragefilenameallsortedextrasamples.txt",sep=" ",header=F)
names(CoverageExtraSamples)[names(CoverageExtraSamples) == 'V1'] <- 'SeqID'
names(CoverageExtraSamples)[names(CoverageExtraSamples) == 'V2'] <- 'Coverage'
CoverageExtraSamples$Filepath<-CoverageExtraSamples$SeqID
CoverageExtraSamples$Filepath <- gsub("^.{0,4}", "", CoverageExtraSamples$Filepath)
CoverageExtraSamples$SeqID<-sub('.', '', CoverageExtraSamples$SeqID)
CoverageExtraSamples<-CoverageExtraSamples %>% separate(SeqID, c('Filepath1', 'Filepath2', 'Filepath3', 'Filepath4','Plate','Filepath5','SeqID'), sep = '/', convert = TRUE)
CoverageExtraSamples = subset(CoverageExtraSamples, select = c(Plate, SeqID, Coverage, Filepath))
CoverageExtraSamples$ID<-CoverageExtraSamples$SeqID

```

## Ch.1 BirdIDs

Linking SeqIDs to BirdIDs as in field database

```{r birdids, eval= TRUE, warning=FALSE, include=TRUE}
##Files to match BirdIDs
Identifiers<-read_excel("SheffieldSubmissions.xlsx")
Identifiers26076<-read_excel("ID 26076_Sample information table.xlsx")
PilotIdentifiers<-read_excel("SamplesForPilotTargetCapture_290119_sortBTN_Qubit.xlsx")
LIMS26629renamed<-read.table("lims26629renamed.txt",sep=" ",header=F)
LIMS26757p1raw4<-read.csv("Samples for Sequencing 25072023.csv",colClasses=c("NULL",NA,NA,NA,NA,NA))
MissingLIMS26757p1raw4 <- data.frame(BirdID=c(6572,6145,6373,5904,6144,6651), 
                                    FieldRing=c(NA,NA,NA,NA,NA,NA),
                                    BTO=c(NA,NA,NA,NA,NA,NA), 
                                    BloodID=c(8178, 5883,6287,5620,5880,7239), 
                                    BloodTubeNumber=c(NA,NA,NA,NA,NA,NA), 
                                    stringsAsFactors=FALSE)
LIMS26757p1raw4<-rbind(LIMS26757p1raw4,MissingLIMS26757p1raw4)
BloodID<-read.csv("BloodID.csv")

##Clean ID numbers
LIMS26629renamed<-LIMS26629renamed %>% arrange(V1)
LIMS26629renamed$SeqID<-CoverageExtraSamples$SeqID[CoverageExtraSamples$Plate=='LIMS26629']
LIMS26629renamed<-LIMS26629renamed %>%
  mutate(SeqID=sort(SeqID))
LIMS26629renamed$V1<-sub(".*\\-", "", LIMS26629renamed$V1)
colnames(LIMS26629renamed)[colnames(LIMS26629renamed) == 'V1'] <- 'ID'

#Fix 6 samples that were mislabeled, as identified by Rowan
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "100_ACAAGAACCT-CGATACTGAA_L002__all_mapped_rehead.bam")] <- 2544
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "101_AGAGTATGTG-AGATGGCTTC_L002__all_mapped_rehead.bam")] <- 3227
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "96_CAACCATACA-ACCGGTTATA_L002__all_mapped_rehead.bam")] <- 764
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "97_GTAGGCCGTT-GCCACTGTCT_L002__all_mapped_rehead.bam")] <- 2688
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "98_CGGATTGATC-AGTCACAACA_L002__all_mapped_rehead.bam")] <- 2493
LIMS26629renamed$ID[which(LIMS26629renamed$SeqID == "99_ACTGGCAAGA-TGTTGTCCAT_L002__all_mapped_rehead.bam")] <- 2522

CoverageExtraSamples$ID[CoverageExtraSamples$Plate=="LIMS26629"]<-NA
CoverageExtraSamples <- merge(CoverageExtraSamples,LIMS26629renamed,by="SeqID", all = TRUE) %>%
  mutate(ID = coalesce(ID.x, ID.y)) %>%
  select (-c(ID.x, ID.y))



PilotSequences<-subset(CoverageExtraSamples, CoverageExtraSamples$Plate=="LIMS24675"|CoverageExtraSamples$Plate=="LIMS25133")
PilotSequences$ID<-trimws(sapply(strsplit(PilotSequences$ID, "_"), `[[`, 2))
MissingBloodIDSequences<-subset(CoverageExtraSamples, CoverageExtraSamples$Plate == "LIMS26076p4"|CoverageExtraSamples$Plate == "LIMS26076raw")
MissingBloodIDSequences$ID<-as.numeric(sapply(strsplit(MissingBloodIDSequences$ID, "_"), "[[", 1))
BloodIDSequences<-subset(CoverageExtraSamples, CoverageExtraSamples$Plate!="LIMS24675"& CoverageExtraSamples$Plate!="LIMS25133"&CoverageExtraSamples$Plate != "LIMS26076p4"&CoverageExtraSamples$Plate != "LIMS26076raw" )
BloodIDSequences$ID <- sub('_repeat','',BloodIDSequences$ID)
BloodIDSequences$ID <- sub('-repeat','',BloodIDSequences$ID)
BloodIDSequences$ID<-trimws(sapply(strsplit(BloodIDSequences$ID, "_"), `[[`, 1))
BloodIDSequences$ID<-sub('.+-(.+)', '\\1', BloodIDSequences$ID)

##Pilot sequences use Blood Tube Number, the rest use BloodID
PilotSequences$Identifier<-paste("BloodTubeNumber")
MissingBloodIDSequences$Identifier<-paste("BloodID")
BloodIDSequences$Identifier<-paste("BloodID")

##Make IDs numeric
PilotSequences$ID<-as.numeric(PilotSequences$ID)
BloodIDSequences$ID<-as.numeric(BloodIDSequences$ID)
MissingBloodIDSequences$ID<-as.numeric(MissingBloodIDSequences$ID)
Identifiers26076$Sample_number<-as.numeric(Identifiers26076$`Sample number`)
Identifiers26076$BloodID<-as.numeric(Identifiers26076$`Sample name`)

#Join BirdIDs
PilotSequences <- PilotSequences %>% 
  left_join(select(PilotIdentifiers, BirdID, BloodTubeNumber), by = c("ID" = "BloodTubeNumber"))

BloodIDSequences$BloodID<-BloodIDSequences$ID
BloodIDSequences <- BloodIDSequences %>% 
  left_join(select(Identifiers, BirdID, BloodID), by = c("ID" = "BloodID"))
names(BloodIDSequences)[names(BloodIDSequences) == 'BirdID.x'] <- 'BirdID'
BloodIDSequences<-BloodIDSequences[!duplicated(BloodIDSequences), ]

MissingBloodIDSequences <- MissingBloodIDSequences %>% 
  left_join(select(Identifiers26076, Sample_number, BloodID), by = c("ID" = "Sample_number"))
MissingBloodIDSequences <- MissingBloodIDSequences %>% 
  left_join(select(Identifiers, BirdID, BloodID), by = c("BloodID" = "BloodID"))

##Concatenate into one file (2018 individuals including duplicates)
MissingBloodIDSequencesFormatted= subset(MissingBloodIDSequences, select = c(Plate, SeqID, Coverage, Filepath, BloodID, Identifier, BirdID))
colnames(MissingBloodIDSequencesFormatted)[colnames(MissingBloodIDSequencesFormatted) == 'BloodID'] <- 'ID'
BloodIDSequencesFormatted= subset(BloodIDSequences, select = c(Plate, SeqID, Coverage, Filepath, ID, Identifier, BirdID))
SequencedIndividualsBirdIDs=rbind(PilotSequences,MissingBloodIDSequencesFormatted,BloodIDSequencesFormatted)

##Add in missing BirdIDs from LIMS26757p1raw4
SequencedIndividualsBirdIDsExtra<- SequencedIndividualsBirdIDs %>% 
  left_join(select(LIMS26757p1raw4, BirdID, BloodID), by = c("ID" = "BloodID")) %>%
  mutate(BirdID = coalesce(BirdID.x, BirdID.y)) %>%
  select (-c(BirdID.x, BirdID.y))

SequencedIndividualsBirdIDsExtraDeduplicated<- SequencedIndividualsBirdIDsExtra %>% 
  group_by(BirdID) %>%
  top_n(1, abs(Coverage))
```

## Ch.1 Test panel

This script helped me find plates and well positions for cherry-picking samples at Liverpool to re-sequence. Samples were chosen following commands in the 9choosereferencepanel.sh bash script picking the best 250 coverage that were unrelated to at least a 2nd degree.

```{r testpanel, eval=TRUE, warning=FALSE }
##Choose samples to resequence
BestCoverageUnrelated<-read.table("unrelatedimputedchromosomes250sampled2nddegree.king.cutoff.in.id")
BestCoverageUnrelated$SeqID<-basename(BestCoverageUnrelated$V2)
BestCoverageUnrelatedSampleID<- merge(BestCoverageUnrelated, SequencedIndividualsBirdIDsExtraDeduplicated, by="SeqID", all = FALSE)
BestCoverageUnrelatedToResequence<-BestCoverageUnrelatedSampleID %>%
  select(SeqID, Plate, ID, Identifier, BirdID, Coverage )
###Add in plate and well numbers to help find libraries
BestCoverageUnrelatedToResequenceWellID<- merge(BestCoverageUnrelatedToResequence, Identifiers, by="BirdID", all = FALSE)
Identifiers26076<- Identifiers26076 %>% 
  left_join(select(BloodIDSequences, BloodID, BirdID) , by = c("BloodID" = "BloodID"))
BestCoverageUnrelatedToResequenceWellIDPlate <- merge(BestCoverageUnrelatedToResequenceWellID, Identifiers26076, by= "BirdID", all= TRUE)
BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate, !is.na(BestCoverageUnrelatedToResequenceWellIDPlate$SeqID))
BestCoverageUnrelatedToResequenceWellIDPlate <- BestCoverageUnrelatedToResequenceWellIDPlate[-c(18, 20, 21), ]

BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate,BestCoverageUnrelatedToResequenceWellIDPlate$Identifier=="BloodID")

BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate,BestCoverageUnrelatedToResequenceWellIDPlate$Plate.x!="LIMS24675")
BestCoverageUnrelatedToResequenceWellIDPlate <- subset(BestCoverageUnrelatedToResequenceWellIDPlate,BestCoverageUnrelatedToResequenceWellIDPlate$Plate.x!="LIMS25133")

openxlsx::write.xlsx(BestCoverageUnrelatedToResequenceWellIDPlate, file ="BestCoverageUnrelatedToResequenceWellIDPlate.xlsx", quote=FALSE)
getwd()

```

This script creates a set of UNIX commands to merge re-sequenced samples creating a higher coverage test set to assess imputation accuracy. Re-sequenced samples were verified as duplicates using PLINK.

```{r warning=FALSE, include=FALSE}
##Merge reference panel
SequencedIndividualsBirdIDsExtraDeduplicated<- SequencedIndividualsBirdIDsExtra %>% 
  group_by(BirdID) %>%
  top_n(1, abs(Coverage))
###These samples have been checked they are indeed duplicates using PLINK
ReferencePanel<- read.delim("duplicatereferencepairs0.3na1.kin0",sep=" ",header=T,col.names=c("","Resequence","","SeqID","","","",""),row.names=NULL)
ReferencePanel<- subset(ReferencePanel, select = -c(X,X.1,X.2,X.3,X.4,X.5) )
ReferencePanel[] <- lapply(ReferencePanel, gsub, pattern='./Clean_aligned/', replacement='')

#Add in filepaths
ReferencePanel<-merge(ReferencePanel, SequencedIndividualsBirdIDsExtraDeduplicated , by="SeqID") %>%
                        select(Resequence,Filepath) 
ReferencePanel$Merged_output<-ReferencePanel$Filepath
ReferencePanel$Resequence <- sub("^", "/fastdata/bop21kgl/RawData/LIMS202103/Clean_aligned/", ReferencePanel$Resequence )
ReferencePanel$Merged_output<-gsub(".*/","",ReferencePanel$Merged_output)
ReferencePanel$Merged_output <- sub("^", "/fastdata/bop21kgl/RawData/LIMSMERGED/Clean_aligned/", ReferencePanel$Merged_output )
ReferencePanel$Command= "samtools merge"
ReferencePanel<-ReferencePanel[,c(4,3,1,2)]

#Write out commands for samtools to merge files
write.table(ReferencePanel, file = "ReferencePanel.txt", sep = " ",
            col.names = F, row.names = F, quote = FALSE)

openxlsx::write.xlsx(ReferencePanel, file ="ReferencePanel.xlsx", quote=FALSE)

```

## Ch.1 SeqIDs (2nd round of imputation with "test" panel)

```{r seqids2, eval=TRUE, echo=FALSE}

TestPanelSamples<- read.delim("coveragefilenameallsortedextrasamplesimputed.txt",sep=" ",header=F)
names(TestPanelSamples)[names(TestPanelSamples) == 'V1'] <- 'SeqID'
names(TestPanelSamples)[names(TestPanelSamples) == 'V2'] <- 'Coverage'
TestPanelSamples$Filepath<-TestPanelSamples$SeqID
TestPanelSamples$Filepath <- gsub("^.{0,4}", "", TestPanelSamples$Filepath)
TestPanelSamples$SeqID<-sub('.', '', TestPanelSamples$SeqID)
TestPanelSamples<-TestPanelSamples %>% separate(SeqID, c('Filepath1', 'Filepath2', 'Filepath3', 'Filepath4','Plate','Filepath5','SeqID'), sep = '/', convert = TRUE)
TestPanelSamples = subset(TestPanelSamples, select = c(Plate, SeqID, Coverage, Filepath))
TestPanelSamples$ID<-TestPanelSamples$SeqID
TestPanelSamples<-subset(TestPanelSamples, TestPanelSamples$Plate=="LIMSMERGED")

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(TestPanelSamples %>% select(SeqID, Plate, Coverage, Filepath), by = "SeqID", suffix = c(".orig", ".new")) %>%
  mutate(
    Plate = coalesce(Plate.new, Plate.orig),  # Replace Plate.orig with Plate.new
    Coverage = coalesce(Coverage.new, Coverage.orig),  # Replace Coverage.orig with Coverage.new
    Filepath = coalesce(Filepath.new, Filepath.orig)  # Replace Coverage.orig with Coverage.new
  ) %>%
  select(-Plate.new, -Coverage.new, -Filepath.new)  # Remove the extra columns from the join

##Create downsample factor for samples to downsample using /SNPsSeychellesWarbler/blob/main/3_Imputation_accuracy/4downsamplecorrectcoverage.sh before imputing with STITCH
DownsampleReferencePanel<-subset(SequencedIndividualsBirdIDsExtraDeduplicated, SequencedIndividualsBirdIDsExtraDeduplicated$Plate=="LIMSMERGED")
DownsampleReferencePanel$Multiplier0.1X<-1/DownsampleReferencePanel$Coverage
DownsampleReferencePanel<-DownsampleReferencePanel %>%
  ungroup() %>%
  select(Filepath, Multiplier0.1X)

write.table(ReferencePanel, file = "downsamplescalingnew", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Imputation accuracy figure
STITCHaccuracy<- read.xlsx("STITCHaccuracy.xlsx",  sep = "\t")

ggplot(STITCHaccuracy, aes(x = Size..genome.percentage., y = Imputation.accuracy.0.1x)) +
  geom_point() +  # Scatter plot
  geom_text_repel(aes(label = Chromosome), 
                size = 5, 
                force = 10, 
                point.padding = 0.5, 
                max.overlaps = Inf)  +
  labs(x = "Chromosome size (genome %)", 
       y = "Imputation accuracy (0.1x)") +
  theme_classic()+
  theme(
    text = element_text(size = 20),            # Default text size
    axis.title.x = element_text(size = 20, margin = margin(t = 15)),
    axis.title.y = element_text(size = 20, margin = margin(r = 15)),
    axis.text = element_text(size = 16),        # Axis tick labels
    plot.title = element_text(size = 32, face = "bold"),  # Title
    legend.text = element_text(size = 16),      # Legend text
    legend.title = element_text(size = 20),
    legend.position = "bottom",
    panel.background = element_blank(),        # Remove background color
    plot.background = element_blank()
) 

```

## Ch.1 Genotype sex

This is important to check if we have assigned IDs correctly. If the sex of sample as calculated by imputed genotypes does not match the sex as recorded by CHD gene sexing from the field database, something must be up.

```{r sex, eval=TRUE, echo = TRUE, tidy=FALSE}
##Load field database sex data
BirdIDSexYear <- read_excel("BirdIDSexYear.xlsx")


##Add in field database sex of bird
SequencedIndividualsBirdIDsExtraDeduplicated <- merge(SequencedIndividualsBirdIDsExtraDeduplicated, BirdIDSexYear[, c("BirdID", "Sex")], by = "BirdID", all.x = TRUE)
SequencedIndividualsBirdIDsExtraDeduplicated<-SequencedIndividualsBirdIDsExtraDeduplicated[!duplicated(SequencedIndividualsBirdIDsExtraDeduplicated),]

##Add in genotype sex of bird (proportion missing genotypes of W chromosome)
W<-read.table("genotype_missing_chr.smiss", header=FALSE, col.names=c("Filepath", "Present", "Total","WProportionMissing"))
hist(W$WProportionMissing, breaks=120)


##Add in genotype sex of bird (heterozygosity of Z chromosome)
Zheterozygosity <- read.table("plink2.scount",header=TRUE, col.names=c("Filepath", "nHom", "nHet"))
Zheterozygosity$Het<- Zheterozygosity$nHet/(Zheterozygosity$nHom+Zheterozygosity$nHet)
Zheterozygosity$Het <- round(Zheterozygosity$Het, 5)
hist(Zheterozygosity$Het, breaks=120)

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(Zheterozygosity , by = "Filepath")


SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(W , by = "Filepath")

##Add in genotype sex of bird (Z:W coverage and Autosome:Z coverage)
SexChromosomeCoverage<-read.table(file = "zw_autosomew_coverageall_clean.txt",sep=" ",header=F, col.names = c("SeqID","RatioZW", "RatioAutosomesW", "RatioAutosomesZ", "Mean_autosomes_cov", "Z_cov" , "W_cov"),  fill = TRUE)
SexChromosomeCoverage$Mean_autosomes_cov<-as.numeric(SexChromosomeCoverage$Mean_autosomes_cov)
SexChromosomeCoverage$RatioZW<-as.numeric(SexChromosomeCoverage$RatioZW)
SexChromosomeCoverage$RatioAutosomesW<-as.numeric(SexChromosomeCoverage$RatioAutosomesW)
SexChromosomeCoverage$RatioAutosomesZ<-as.numeric(SexChromosomeCoverage$RatioAutosomesZ)
hist(SexChromosomeCoverage$RatioAutosomesZ, breaks=120)
SexChromosomeCoverage<- SexChromosomeCoverage %>% 
  group_by(SeqID) %>%
  top_n(1, abs(Mean_autosomes_cov))
SexChromosomeCoverage<-SexChromosomeCoverage[!duplicated(SexChromosomeCoverage),]


SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  left_join(SexChromosomeCoverage , by = "SeqID")


SequencedIndividualsBirdIDsExtraDeduplicated$Sex <- as.factor(SequencedIndividualsBirdIDsExtraDeduplicated$Sex)
SequencedIndividualsBirdIDsExtraDeduplicated$W_cov <- as.numeric(SequencedIndividualsBirdIDsExtraDeduplicated$W_cov)
SequencedIndividualsBirdIDsExtraDeduplicated$Z_cov <- as.numeric(SequencedIndividualsBirdIDsExtraDeduplicated$Z_cov)
SequencedIndividualsBirdIDsExtraDeduplicated$ProportionalZCoverage <- 
  SequencedIndividualsBirdIDsExtraDeduplicated$Z_cov / SequencedIndividualsBirdIDsExtraDeduplicated$Coverage

hist(SequencedIndividualsBirdIDsExtraDeduplicated$ProportionalZCoverage, breaks=120)

# Predict sex using a model
SexPrediction <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  filter(!is.na(Het) & !is.na(ProportionalZCoverage)& RatioZW > 0)


#Build model 
logisticSexModel <- glm(Sex ~ ProportionalZCoverage * WProportionMissing +nHet,
                      data = SexPrediction,
                      family = "binomial")

#Assign sex based off model
predicted_probs <- predict(logisticSexModel, SexPrediction, type = "response")
predicted_sex <- ifelse(predicted_probs > 0.5, "1", "0")

# Add the predicted sex to the data
SexPrediction$PredictedSex <- predicted_sex

# Identify rows where CHD gene sex does not match the predicted sex
SexMismatches <- SexPrediction[SexPrediction$Sex != SexPrediction$PredictedSex, ]

SexPrediction$ProportionalZCoverage150<-SexPrediction$ProportionalZCoverage*150
SexMismatches$ProportionalZCoverage150<-SexMismatches$ProportionalZCoverage*150

SexPrediction$Sex <- factor(SexPrediction$Sex, levels = c(0, 1), labels = c("Female (ZW)", "Male (ZZ)"))

# Create the ggplot
p <- ggplot(subset(SexPrediction, SexPrediction$RatioZW > 0), aes(x = ProportionalZCoverage150, y = WProportionMissing, color = Sex)) +
  geom_point() +  # Scatter plot of the data
  geom_text_repel(data = SexMismatches, 
                  aes(x = ProportionalZCoverage150, y = WProportionMissing, label = BirdID), 
                  color = "black", 
                  size = 6,  # Adjust label size
                  box.padding = 0.5,  # Space between label and point
                  max.overlaps = 50,  # Limit the number of overlaps (e.g., 50 labels can overlap)
                  force = 2,  # Set force to avoid excessive movement of labels
                  max.iter = 1000,  # Limit number of iterations for adjusting the labels
                  segment.size = 0.5) +  # Adjust the segment size connecting the labels
  labs(x = "Z coverage", y = "W proportion missing genotypes") +
  theme_classic() +  # Minimal theme
  scale_color_manual(values = c("Female (ZW)" = "red", "Male (ZZ)" = "blue")) +  # Set colors and labels
  xlim(min(SexPrediction$ProportionalZCoverage150) - 0, max(SexPrediction$ProportionalZCoverage150) + 0) +  # Adjust plot limits
  ylim(min(SexPrediction$WProportionMissing) - 0, max(SexPrediction$WProportionMissing) + 0) +
  theme(
    axis.title.x = element_text(size = 20),  # Increase x-axis title size
    axis.title.y = element_text(size = 20),  # Increase y-axis title size
    plot.title = element_text(size = 28, face = "bold"),  # Increase plot title size
    axis.text = element_text(size = 16),  # Increase axis tick labels size
    legend.text = element_text(size = 16),  # Increase legend text size
    legend.title = element_text(size = 18)  # Increase legend title size
  )

# Add marginal plots
p_marginal <- ggMarginal(p, 
                         type = "density", 
                         fill = c("red", "blue"), 
                         alpha = 0.2,
                         margins = "both",  # Adds histograms on both axes
                         groupColour = TRUE, 
                         groupFill = TRUE)
p_marginal

#ggsave("sexing.png", plot = p_marginal, width = 10, height = 8)

```

## Ch.1 Life-history traits

```{r life-history, eval=TRUE, echo=FALSE, include=TRUE}

#Lifespan ----
##Read files
BirthDate <- read_csv("BirthDate27032023.csv", col_types = cols(BirthDate = col_date(format = "%d/%m/%Y"))) #In query table, this is BirdID
LastSeenYear <- read_excel("CurrentBTOextended032025.xlsx") #In query table, this is CurrentBTOextended
LastSeenYear <- LastSeenYear %>%
  rename(LastSeenYear = LastSeenYea)
BirdIDSexYear <- read_excel("BirdIDSexYear.xlsx")

##Make terms
###BirthYear from BirthDate
BirthDate <- BirthDate %>% 
  mutate(BirthYear = format(BirthDate, "%Y")) %>%
  mutate(BirthYear = as.numeric(BirthYear))

###Lifespan
SequencedIndividualsBirdIDsExtraDeduplicated <- merge(
  SequencedIndividualsBirdIDsExtraDeduplicated, 
  BirthDate[, c("BirdID", "BirthYear")], 
  by = "BirdID", 
  all.x = TRUE  # Ensure all rows from SequencedIndividualsBirdIDsExtraDeduplicated are kept
)

# First, merge LastSeenYear and DeathYear into SequencedIndividualsBirdIDsExtraDeduplicated
SequencedIndividualsBirdIDsExtraDeduplicated <- merge(
  SequencedIndividualsBirdIDsExtraDeduplicated, 
  LastSeenYear[, c("BirdID", "LastSeenYear")], 
  by = "BirdID", 
  all.x = TRUE  # Keep all rows from SequencedIndividualsBirdIDsExtraDeduplicated
)
SequencedIndividualsBirdIDsExtraDeduplicated <- merge(
  SequencedIndividualsBirdIDsExtraDeduplicated, 
  BirthDate[, c("BirdID", "DeathYear")], 
  by = "BirdID", 
  all.x = TRUE  # Keep all rows from SequencedIndividualsBirdIDsExtraDeduplicated
)

# Calculate Lifespan
SequencedIndividualsBirdIDsExtraDeduplicated$Lifespan <- ifelse(
  !is.na(SequencedIndividualsBirdIDsExtraDeduplicated$LastSeenYear), 
  SequencedIndividualsBirdIDsExtraDeduplicated$LastSeenYear - SequencedIndividualsBirdIDsExtraDeduplicated$BirthYear, 
  SequencedIndividualsBirdIDsExtraDeduplicated$DeathYear - SequencedIndividualsBirdIDsExtraDeduplicated$BirthYear
)

#Add in 6070 as this bird died in the nest
SequencedIndividualsBirdIDsExtraDeduplicated$DeathYear <- ifelse(
  SequencedIndividualsBirdIDsExtraDeduplicated$BirdID == 6070, 
  2013, 
  SequencedIndividualsBirdIDsExtraDeduplicated$DeathYear
)

SequencedIndividualsBirdIDsExtraDeduplicated$Lifespan <- ifelse(
  SequencedIndividualsBirdIDsExtraDeduplicated$BirdID == 6070, 
  0, 
  SequencedIndividualsBirdIDsExtraDeduplicated$Lifespan
)


##Link n offspring to dataframe
Offspring <- read_csv("Offspring27032023.csv",col_types = cols(BirthDate = col_date(format = "%d/%m/%Y")))
ROcount <- Offspring %>% filter(Confidence > 80) %>% count(Parent) %>% rename(BirdID = Parent,ReproductiveOutput = n)
SequencedIndividualsBirdIDsExtraDeduplicated<- merge(SequencedIndividualsBirdIDsExtraDeduplicated, ROcount, by="BirdID", all = TRUE)

SequencedIndividualsBirdIDsExtraDeduplicated <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  filter(!is.na(SeqID))


```

## Ch.1 Pedigree

Pedigree construction by *sequoia.* 572 SNPs were chosen after filtering for minor allele frequency \> 0.3, genotyping rate \> 99.9 and for linkage and also excluding SNPs on sex chromosomes and on chromosomes with \<90% imputation accuracy. Parentge assignment comparison suggests masterbayes is at least 94% accurate so is useful for verifying sample identities where there are mixups.

```{r pedigree, eval = TRUE, echo = TRUE, tidy=FALSE}
#Deduplicate samples for sequioa as it doesn't handle duplicates
DeduplicatedforSequoia<-data.frame(rep("0",length(SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)),SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)
write.table(DeduplicatedforSequoia, file = "DeduplicatedforSequoia.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Rename samples for sequioa to BirdIDs
RenameforSequoia<-data.frame(rep("0",length(SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)),SequencedIndividualsBirdIDsExtraDeduplicated$Filepath,rep("0",length(SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)),SequencedIndividualsBirdIDsExtraDeduplicated$BirdID)
write.table(RenameforSequoia, file = "RenameforSequoia.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Read in SNPs in .raw format
sw_GenoM_family <- GenoConvert(InFile = "reimputedinputfile_for_sequoia.raw", InFormat="raw")

#Read in pedigree from masterbayes
masterped <- read.csv("pedFINAL_var124567_combined_unique_20230413.csv")
head(masterped)
names(masterped)[names(masterped) == 'dad'] <- 'sire'
names(masterped)[names(masterped) == 'mum'] <- 'dam'

#drop unnecessary column
masterped <- masterped[-c(4)]

#Read in life history data
sw_LifeHistData <- read.csv("LifeHistoryData.csv", header = TRUE)
sw_LifeHistData<-sw_LifeHistData[!duplicated(sw_LifeHistData),]
sw_LifeHistData$Sex <- case_when(sw_LifeHistData$Sex == "0" ~ 1, 
                                 sw_LifeHistData$Sex == "1" ~ 2, 
                                 TRUE ~ 3)

#drop birds born before 1991 as they are not sampled
sw_LifeHistData <- sw_LifeHistData[sw_LifeHistData$Year > 1990,]

#drop birds not in cousin
sw_LifeHistData <- sw_LifeHistData[sw_LifeHistData$Island == "CN",]

#drop unnecessary column
sw_LifeHistData <- sw_LifeHistData[,-2]
sw_LifeHistData <- sw_LifeHistData[,-3]

sw_LifeHistData<-na.omit(sw_LifeHistData)

#Looks like lots of duplicate BirdIDs so create new life hist file
BirthDate <- read_csv("BirthDate27032023.csv", col_types = cols(BirthDate = col_date(format = "%d/%m/%Y"))) #In query table, this is BirdID
BirdIDSexYear <- read_excel("BirdIDSexYear.xlsx")
lifehist<- merge(BirthDate, BirdIDSexYear, by= "BirdID", all= TRUE)%>%
  select(BirdID,Sex,BirthDate)
lifehist<-lifehist[!duplicated(lifehist),]
lifehist$Sex <- case_when(lifehist$Sex == "0" ~ 1, 
                          lifehist$Sex == "1" ~ 2, 
                                 TRUE ~ 3)
lifehist$BirthDate<-format(as.Date(lifehist$BirthDate, format="%Y/%m/%d"),"%Y")
colnames(lifehist)[colnames(lifehist) == 'BirthDate'] <- 'Year'
lifehist<-lifehist[-c(1, 2), ]  

# 1. Initial diagnostics --------------------------------------------------

# Check genotype calls across the dataset (-9 = missing calls)
summary.factor(as.factor(sw_GenoM_family))/(nrow(sw_GenoM_family)*ncol(sw_GenoM_family))

# Check for Mendelian errors in the data at the locus level
GenoM_checks <- SnpStats(sw_GenoM_family, Ped = masterped[,c("id", "dam", "sire")])

ggplot(GenoM_checks, aes(x = OHdam)) + geom_histogram() + theme_classic()
ggplot(GenoM_checks, aes(x = OHsire)) + geom_histogram() + theme_classic()
sw_OHLLR_DATABASE <- CalcOHLLR(Pedigree = masterped[,c("id", "dam", "sire")], GenoM = sw_GenoM_family)
ggplot(sw_OHLLR_DATABASE, aes(y = LLRdam, x = OHdam)) + geom_point(alpha = 0.6) + theme_classic()
ggplot(sw_OHLLR_DATABASE, aes(y = LLRsire, x = OHsire)) + geom_point(alpha = 0.6) + theme_classic()
SummarySeq(sw_OHLLR_DATABASE, Panels = "OH")

# 2. Run basic sequoia ------------------------------------

# Note modules used to build up from basic input check to analysis:
# i.   'pre': Input check
# ii.  'dup': check for duplicates
# iii. 'par': parentage assignment
# iv.  'ped': full pedigree reconstruction

# Just parentage assignment (Module = "par"). 
sw_family_sequoia_justparents <- sequoia(GenoM = sw_GenoM_family, LifeHistData = lifehist, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

# A 94.0% match to the masterbayes pedigree
sw_family_pedigree_justparents_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents$Pedigree, Plot=TRUE, Symmetrical = TRUE)

SummarySeq(SeqList = sw_family_sequoia_justparents)


# Full pedigree reconstruction (Module = "ped"). Hashed out of knit because takes too long.
#sw_family_sequoia <- sequoia(GenoM = sw_GenoM_family, LifeHistData = lifehist, Module = "ped", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))
#sw_family_pedigree_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia$Pedigree, Plot=TRUE)$MergedPed

```


## Ch.1 Sample mismatches

Investigating mismatches between field database and genotype data.
```{r sample_mismatch, eval=TRUE, echo=TRUE, include=TRUE}
library(dplyr)
# First let's deal with sex mismatches. Recall the mismatches outputted from the model
view(SexMismatches)

PedigreeMismatch<-sw_family_pedigree_justparents_comparison[["Mismatch"]]
TestPedigreeMismatch<-sw_family_pedigree_justparents_comparison[["MergedPed"]]
TestPedigreeMismatchSubset <- TestPedigreeMismatch %>%
  filter(!(dam.class == "Match" | sire.class == "Match"))


SexMismatches$BirdID <- as.character(SexMismatches$BirdID)
PedigreeMismatch$id <- as.character(PedigreeMismatch$id)
TestPedigreeMismatchSubset$id <- as.character(TestPedigreeMismatchSubset$id)

SexMismatches$PedigreeMismatch <- apply(SexMismatches, 1, function(row) {
  any(row["BirdID"] %in% unlist(PedigreeMismatch))
})
# Assuming PedigreeMismatch is a dataframe with an 'id' column
SexMismatches$PedigreeMismatch <- apply(SexMismatches, 1, function(row) {
  any(row["BirdID"] %in% PedigreeMismatch$id)
})

#For BirdID: 1668, SeqID: 98-1015_221007_L003__all_mapped_rehead.bam, the bird was only seen twice in 2002 (Unknown) and 2003 (SEEN1). Field database is marked as male by molecular sexing but female by observation. INCLUDE AS F?


#We can try find which bird it is we incorrectly sampled for sequencing.
##Change sex of samples to "unknown" in sequoia and re-run parentage assignment. Then see which bird is it's parents and offspring and compare to microsat pedigree.
lifehistsexunknown<-lifehist
lifehistsexunknown$Sex[lifehistsexunknown$BirdID %in% SexMismatches$BirdID] <- 3

# Just parentage assignment (Module = "par"). 
sw_family_sequoia_justparents <- sequoia(GenoM = sw_GenoM_family, LifeHistData = lifehistsexunknown, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

sw_family_pedigree_justparents_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents$Pedigree, Plot=TRUE, Symmetrical = TRUE)

#Any duplicate samples  in sequoia input SNPs? Yes, 29.
DuplicatesSequoia<-sw_family_sequoia_justparents[["DupGenotype"]]

# Verify these from PLINK, calling duplicates by --king-table-filter 0.35 for 487,107 SNPs (genotyping rate > 99.9 and MAF > 0.3)
UnintentionalDuplicates<- read.table("unintentionalduplicates.kin0", stringsAsFactors = FALSE)
PLINKDuplicates<- read.table("unintentionalduplicates.kin0", stringsAsFactors = FALSE)
# Loop through rows of UnintentionalDuplicates and add BirdID from SequencedIndividualsBirdIDsExtraDeduplicated to V1 where V2 matches Filepath
# Loop through rows of UnintentionalDuplicates and add BirdID from SequencedIndividualsBirdIDsExtraDeduplicated to V1 where V2 matches Filepath
#Add BirdIDs
UnintentionalDuplicates$V1[UnintentionalDuplicates$V2 %in% SequencedIndividualsBirdIDsExtraDeduplicated$Filepath] <- 
  SequencedIndividualsBirdIDsExtraDeduplicated$BirdID[match(UnintentionalDuplicates$V2, SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)]

UnintentionalDuplicates$V3[UnintentionalDuplicates$V4 %in% SequencedIndividualsBirdIDsExtraDeduplicated$Filepath] <- 
  SequencedIndividualsBirdIDsExtraDeduplicated$BirdID[match(UnintentionalDuplicates$V4, SequencedIndividualsBirdIDsExtraDeduplicated$Filepath)]

# Rename columns in UnintentionalDuplicates
colnames(UnintentionalDuplicates) <- c("BirdID1", "Filepath1", "BirdID2", "Filepath2", "NSNPs", "V6", "V7", "Kinship")

# Subset UnintentionalDuplicates to remove rows where Kinship is NA
UnintentionalDuplicates <- UnintentionalDuplicates[!is.na(UnintentionalDuplicates$Kinship), ]

# Initialize the new column with FALSE (or NA) in UnintentionalDuplicates
UnintentionalDuplicates$SexMismatchedDuplicate <- FALSE

# Loop through each BirdID in SexMismatches to check if it matches in either BirdID1 or BirdID2 in UnintentionalDuplicates
for (i in 1:nrow(SexMismatches)) {
  matching_rows <- UnintentionalDuplicates[UnintentionalDuplicates$BirdID1 == SexMismatches$BirdID[i] |
                                           UnintentionalDuplicates$BirdID2 == SexMismatches$BirdID[i], ]
  
  if (nrow(matching_rows) > 0) {
    UnintentionalDuplicates$SexMismatchedDuplicate[UnintentionalDuplicates$BirdID1 == SexMismatches$BirdID[i] |
                                                  UnintentionalDuplicates$BirdID2 == SexMismatches$BirdID[i]] <- TRUE
  }
}


# Create a new column in SexMismatches to store the Kinship values
SexMismatches$Kinship <- NA  # Initialize with NA

# Loop through each BirdID in SexMismatched to check if it matches in either BirdID1 or BirdID2 in UnintentionalDuplicates
for (i in 1:nrow(SexMismatches)) {
  matched_row <- UnintentionalDuplicates[UnintentionalDuplicates$BirdID1 == SexMismatches$BirdID[i] |
                                        UnintentionalDuplicates$BirdID2 == SexMismatches$BirdID[i], ]
  
  if (nrow(matched_row) > 0) {
    SexMismatches$Kinship[i] <- matched_row$Kinship[1] 
  }
}


# Initialize the new column in UnintentionalDuplicates with FALSE (or NA)
UnintentionalDuplicates$SequoiaDuplicate <- FALSE

UnintentionalDuplicates$BirdID1 <- as.character(UnintentionalDuplicates$BirdID1)
UnintentionalDuplicates$BirdID2 <- as.character(UnintentionalDuplicates$BirdID2)
DuplicatesSequoia$ID1 <- as.character(DuplicatesSequoia$ID1)
DuplicatesSequoia$ID2 <- as.character(DuplicatesSequoia$ID2)

# Perform a left join to merge UnintentionalDuplicates with relevant columns from DuplicatesSequoia
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(DuplicatesSequoia %>%
              select(ID1, ID2, Mismatch, SnpdBoth, LLR), 
            by = c("BirdID1" = "ID2", "BirdID2" = "ID1")) %>%
  mutate(SequoiaDuplicate = ifelse(BirdID1 %in% DuplicatesSequoia$ID1 | 
                                     BirdID1 %in% DuplicatesSequoia$ID2 |
                                     BirdID2 %in% DuplicatesSequoia$ID1 | 
                                     BirdID2 %in% DuplicatesSequoia$ID2, 
                                   TRUE, FALSE))


#Subset for PLINK Kinship > 0.496 as there are no duplicates over this value 
UnintentionalDuplicates <- subset(UnintentionalDuplicates,UnintentionalDuplicates$Kinship > 0.496)

#There are 29 duplicates as found by sequoia and confirmed with PLINK. Now we need to investigate which is the correct BirdID out of two. 
#11 duplicate pairs can be confirmed using sex
#329 is in fact 1176
#478 is in fact 3444
#4882 is in fact 3643
#4883 is in fact 1607
#5542 is in fact 6136
#5546 is in fact 6175
#5550 is in fact 4961
#5585 is in fact 4943
#6150 is in fact 5786
#6862 is in fact 6670
#1276 is in fact 1765

#15 can be confirmed by comparing with masterbayes mother
# Perform a left join to look up the mother (dam) from masterped using id

Rped.old<-CalcRped(masterped, OUT="DF")
Rel.snp<- read.table("plink2.grm", stringsAsFactors = FALSE)
Rel.id <- read.table("plink2.grm.id", stringsAsFactors=FALSE)
Rel.id<-merge(Rel.id, RenameforSequoia, by.x='V2', by.y='SequencedIndividualsBirdIDsExtraDeduplicated.Filepath') %>% select(V1,SequencedIndividualsBirdIDsExtraDeduplicated.BirdID)
Rel.snp[,1] <- as.character(factor(Rel.snp[,1], labels=Rel.id[,2]))
Rel.snp[,2] <- as.character(factor(Rel.snp[,2], labels=Rel.id[,2]))
names(Rel.snp) <- c("IID1", "IID2", "nSNPS", "R.GRM")
Rel.snp <- Rel.snp[Rel.snp$IID1 != Rel.snp$IID2,] 
Rel.both <- merge(data.table(Rel.snp[,c(1,2,4)], key=c("IID1", "IID2")),
                  data.table(Rped.old, key=c("IID1", "IID2")), all.x=TRUE)

UnintentionalDuplicates$BirdID1 <- as.character(UnintentionalDuplicates$BirdID1)
UnintentionalDuplicates$BirdID2 <- as.character(UnintentionalDuplicates$BirdID2)
Rel.both$IID1<-as.character(Rel.both$IID1)
Rel.both$IID2<-as.character(Rel.both$IID2)

masterped$id <- as.character(masterped$id)

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(masterped %>%
              select(id, dam), 
            by = c("BirdID1" = "id")) %>%
  rename(BirdID1Mum = dam)

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(masterped %>%
              select(id, dam), 
            by = c("BirdID2" = "id")) %>%
  rename(BirdID2Mum = dam)

UnintentionalDuplicates$BirdID1Mum <- as.character(UnintentionalDuplicates$BirdID1Mum)
UnintentionalDuplicates$BirdID2Mum <- as.character(UnintentionalDuplicates$BirdID2Mum)

# Step 1: Perform the joins for BirdID1 and BirdID1Mum
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_1 = R.GRM), 
            by = c("BirdID1" = "IID1", "BirdID1Mum" = "IID2")) %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_2 = R.GRM), 
            by = c("BirdID1" = "IID2", "BirdID1Mum" = "IID1")) %>%
  mutate(BirdID1MumRel = coalesce(R.GRM_1, R.GRM_2))

# Step 2: Perform the joins for BirdID2 and BirdID2Mum
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_3 = R.GRM), 
            by = c("BirdID2" = "IID1", "BirdID2Mum" = "IID2")) %>%
  left_join(Rel.both %>%
              select(IID1, IID2, R.GRM) %>%
              rename(R.GRM_4 = R.GRM), 
            by = c("BirdID2" = "IID2", "BirdID2Mum" = "IID1")) %>%
  mutate(BirdID2MumRel = coalesce(R.GRM_3, R.GRM_4))

PedigreeComparison<-sw_family_pedigree_justparents_comparison[["MergedPed"]]

# Join for BirdID1 and create BirdID1MumMatch
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(PedigreeComparison %>% select(id, dam.class), 
            by = c("BirdID1" = "id")) %>%
  mutate(BirdID1MumMatch = dam.class) %>%
  select(-dam.class)  # Remove dam.class column if not needed

# Join for BirdID2 and create BirdID2MumMatch
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  left_join(PedigreeComparison %>% select(id, dam.class), 
            by = c("BirdID2" = "id")) %>%
  mutate(BirdID2MumMatch = dam.class) %>%
  select(-dam.class)  # Remove dam.class column if not needed

# Remove the unwanted columns R.GRM_1, R.GRM_2, R.GRM_3, and R.GRM_4 from UnintentionalDuplicates
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  select(-R.GRM_1, -R.GRM_2, -R.GRM_3, -R.GRM_4)

#3 can be confirmed comparing with offspring.
#1218/1182. 1182 is probably 1218 because 1218 matches with three different offspring in masterbayes and sequoia
#498/1303. 1303 is probably 498 because 498 has 0.5 relatedness with one offspring (but not the other).
#864/3871. 3871 is probably 864 because 864 matches with offspring.

#Create a BirdIDConsensus column for what the BirdID of the duplicate pair should be
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(BirdIDConsensus = case_when(
    BirdID1 %in% SexMismatches$BirdID ~ as.character(BirdID2),
    BirdID2 %in% SexMismatches$BirdID ~ as.character(BirdID1),
    BirdID1MumMatch == "Match" ~ as.character(BirdID1),
    BirdID2MumMatch == "Match" ~ as.character(BirdID2),
    BirdID1MumRel > 0.5 ~ as.character(BirdID1),
    BirdID2MumRel > 0.5 ~ as.character(BirdID2),
    BirdID1 == 1218 | BirdID2 == 1218 ~ "1218",
    BirdID1 == 498  | BirdID2 == 498  ~ "498",
    BirdID1 == 864  | BirdID2 == 864  ~ "864",
    TRUE ~ NA_character_
  ))

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(BirdIDMissing = case_when(
    BirdID1 == BirdIDConsensus ~ BirdID2,
    BirdID2 == BirdIDConsensus ~ BirdID1,
    TRUE ~ NA_character_
  ))

openxlsx::write.xlsx(UnintentionalDuplicates, file ="UnintentionalDuplicates.xlsx", quote=FALSE)
getwd()

#Re-run sequoia removing the duplicates and only picking the higher coverage sample
UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(
    BirdID1Coverage = case_when(
      BirdID1 %in% SequencedIndividualsBirdIDsExtraDeduplicated$BirdID ~ 
        SequencedIndividualsBirdIDsExtraDeduplicated$Coverage[match(BirdID1, SequencedIndividualsBirdIDsExtraDeduplicated$BirdID)],
      TRUE ~ NA_real_
    ),
    BirdID2Coverage = case_when(
      BirdID2 %in% SequencedIndividualsBirdIDsExtraDeduplicated$BirdID ~ 
        SequencedIndividualsBirdIDsExtraDeduplicated$Coverage[match(BirdID2, SequencedIndividualsBirdIDsExtraDeduplicated$BirdID)],
      TRUE ~ NA_real_
    )
  )

UnintentionalDuplicates <- UnintentionalDuplicates %>%
  mutate(
    BirdIDtoExclude = case_when(
      BirdID1Coverage > BirdID2Coverage ~ BirdID2,
      BirdID1Coverage < BirdID2Coverage ~ BirdID1,
      TRUE ~ NA_character_
    )
  )



# Ensure BirdIDtoExclude is a character vector for comparison
exclude_values <- as.character(UnintentionalDuplicates$BirdIDtoExclude)

# Check if sw_GenoM_family has row names
if (!is.null(rownames(sw_GenoM_family))) {
  
  # Get the row names of sw_GenoM_family
  row_names <- rownames(sw_GenoM_family)
  
  # Find the values in row_names that are in exclude_values
  rows_to_exclude <- row_names %in% exclude_values
  
  # Exclude the rows from sw_GenoM_family where the row names match exclude_values
  sw_GenoM_family_filtered <- sw_GenoM_family[!rows_to_exclude, , drop = FALSE]
  
  print("Rows have been filtered successfully.")
} else {
  print("sw_GenoM_family does not have row names.")
}

sw_dedup_family_sequoia_justparents <- sequoia(GenoM = sw_GenoM_family_filtered, LifeHistData = lifehist, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

# A 95.1% match to the masterbayes pedigree (1% increase after deduplicating)
sw_dedup_family_pedigree_justparents_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_dedup_family_sequoia_justparents$Pedigree, Plot=TRUE, Symmetrical = TRUE)

SummarySeq(SeqList = sw_family_sequoia_justparents)

#Why are there duplicates?
view(Identifiers)

Identifiers$BirdID<-as.character(Identifiers$BirdID)

#It looks like Plate 53 is responsible for 12 duplicates!
UnintentionalDuplicatesMoreInfo<-UnintentionalDuplicates
for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  # Match BirdID1 with Identifiers$BirdID and return Identifiers$Plate in BirdID1Plate
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1Plate[i] <- Identifiers$Plate[match1]
  }
  
  # Match BirdID2 with Identifiers$BirdID and return Identifiers$Plate in BirdID2Plate
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2Plate[i] <- Identifiers$Plate[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1BloodID[i] <- Identifiers$BloodID[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2BloodID[i] <- Identifiers$BloodID[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1BloodTubeNumber[i] <- Identifiers$BTN[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2BloodTubeNumber[i] <- Identifiers$BTN[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1Box[i] <- Identifiers$Box[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2Box[i] <- Identifiers$Box[match2]
  }
}

for (i in 1:nrow(UnintentionalDuplicatesMoreInfo)) {
  
  match1 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID1[i])
  if (length(match1) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID1Plate_number[i] <- Identifiers$`Plate Number`[match1]
  }
  
  match2 <- which(Identifiers$BirdID == UnintentionalDuplicatesMoreInfo$BirdID2[i])
  if (length(match2) > 0) {
    UnintentionalDuplicatesMoreInfo$BirdID2Plate_number[i] <- Identifiers$`Plate Number`[match2]
  }
}

#There are 50 samples in Plate 53
sum(Identifiers$Plate == 53, na.rm = TRUE)
#Is Plate 53 also implicated in the sex mismatches? Yes, 12/26 sex-mismatched samples are from Plate 53.
for (i in 1:nrow(SexMismatches)) {
  
  match <- which(Identifiers$BirdID == SexMismatches$BirdID[i])
  
  if (length(match) > 0) {
    SexMismatches$PlateSheffield[i] <- Identifiers$Plate[match]
  }
}

#Of the sequoia mismatches, how many are from Plate 53? 42/156!
# Assuming PedigreeMismatch and Identifiers are data frames
for (i in 1:nrow(PedigreeMismatch)) {
  
  match_id <- which(Identifiers$BirdID == PedigreeMismatch$id[i])
  if (length(match_id) == 1) {  # Ensure exactly one match
    PedigreeMismatch$idPlate[i] <- Identifiers$Plate[match_id]
  } else {
    PedigreeMismatch$idPlate[i] <- NA  # If no match or multiple matches, assign NA
  }
  
  match_dam <- which(Identifiers$BirdID == PedigreeMismatch$dam.1[i])
  if (length(match_dam) == 1) {  # Ensure exactly one match
    PedigreeMismatch$dam.1Plate[i] <- Identifiers$Plate[match_dam]
  } else {
    PedigreeMismatch$dam.1Plate[i] <- NA  # If no match or multiple matches, assign NA
  }
  
  match_sire <- which(Identifiers$BirdID == PedigreeMismatch$sire.1[i])
  if (length(match_sire) == 1) {  # Ensure exactly one match
    PedigreeMismatch$sire.1Plate[i] <- Identifiers$Plate[match_sire]
  } else {
    PedigreeMismatch$sire.1Plate[i] <- NA  # If no match or multiple matches, assign NA
  }
}
count <- sum(
  grepl("53", PedigreeMismatch$idPlate) |
  grepl("53", PedigreeMismatch$dam.1Plate) |
  grepl("53", PedigreeMismatch$sire.1Plate)
)
count

#Explore how Plate53 looks visually. I don't see any pattern here.
IdentifiersPlate53<-subset(Identifiers, Identifiers$Plate == 53)
# Assuming IdentifiersPlate53 is your data frame with columns BirdID and well

# Create an empty matrix to store the BirdID values
result_matrix <- matrix(NA, nrow = 8, ncol = 12)

# Set the row and column names (A to H for rows, 1 to 12 for columns)
rownames(result_matrix) <- LETTERS[1:8]
colnames(result_matrix) <- 1:12

# Loop through each row in IdentifiersPlate53 to assign BirdID to the appropriate place in the matrix
for (i in 1:nrow(IdentifiersPlate53)) {
  # Extract the well location (e.g., "A1", "B2", or "A10", "B11")
  well <- IdentifiersPlate53$well[i]
  
  # Extract the column number (which may have one or two digits)
  # Identify the split point between the letter (row) and the digits (column)
  col_start <- gregexpr("[0-9]", well)[[1]][1]  # Position of the first digit
  col <- as.integer(substr(well, col_start, nchar(well)))  # Extract the column number
  
  # Extract row letter (A to H)
  row <- substr(well, 1, col_start - 1)  # All characters before the digits are the row letter
  
  # Convert row letter (A = 1, B = 2, ..., H = 8)
  row_num <- which(LETTERS[1:8] == row)
  
  # Assign the BirdID to the appropriate place in the result matrix
  result_matrix[row_num, col] <- IdentifiersPlate53$BirdID[i]
}

result_matrix

#Which sex mismatched samples remain to be resolved?
SexMismatchesToResolve <- SexMismatches %>%
  mutate(DuplicateSample = BirdID %in% c(UnintentionalDuplicates$BirdID1, UnintentionalDuplicates$BirdID2))

#11/29 can be resolved as duplicates
#3/29 genomic sex can't reliably be estimated as coverage < 0.32, include as microsatellite sex?
#7/29 I think can be resolved by investigating relationships with close relatives:
  #3088 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 2 blood samples. Mother is #1716 and father is #1774, which is the masterbayes parents of 5145. SWAP WITH 5145.

  #5145 (F, but geno M) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 2 blood samples. Mother is #1429 and father is #1886, which is the masterbayes parents of 3088. SWAP WITH 3088.

  #6156 (M, but geno F) is  #6160.

  #6160 (M, but geno F) is  #5585 (a bird that was a duplicate but now does not have a sample)

  #6166  is male but geno Female, and mother is 4936 and father is 1731, who is masterbayes parents of 5546. SWAP?

  #774 (F, but geno M) never has offspring according to sequoia, and gets replaced by #329 (#1176) as father to #1176. Has 2 blood samples. BrF from 1996-2002. Exclude as 329 is also a mismastched M but geno F.

#8/29 I am not sure how to treat:

  #1229 (M, but geno F) mother is #825 and then inbreeds with #825 to have  an offspring #1537.

  #1435 (M, but geno F) never had offspring according to sequoia, but had three offspring according to masterbayes. Has 4 blood samples and BrM from 2002-2004. Father is #1181. #1435 is related to 870, 1181 and 1052 by > 0.4. 

  #1676 (M, but geno F) never had offspring according to sequoia, but had one offspring according to masterbayes and gets replaced as father by #1695 (who is BrM in neighboring territory 46 vs 45). Has 1 blood sample as ABX. Mother is #1390. SEX CONFLICT IN DATABASE, INCLUDE AS F?

  #5554 (M, but geno F) mismatched parents and also is a sequoia mother to #5773 and #6034, both times replacing #5111. Has 3 blood samples. Mother is #4863 and father is #1762. Related to 5634, 1884, 511, 5553, 1762 > 0.4. Gets assigned female in pre-deduplicated sequoia pedigree and gets assigned male in deduplicated sequoia pedigree. Is this 5511 (F)?

  #5555 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 1 blood sample as FL. Mother is #3500 and father is #1762. #5554 and #5555 are both males so unlikely to have been swapped. Related to 3500 and 1762 > 0.4. 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)?

  #5827 (F, but geno M) never had offspring (mother only is mismatched)- check how it was sexed in database. Has 1 blood sample as FL. Mother is #3086. Related to 3086, 5339, 5598 > 0.35. 3086 has one offspring in Plate 53: 5831 (M). Is this 5831 (M)? then is 5831 actually 5563?

  #6049 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 3 blood samples. Father is #1750, who is masterbayes father of 6165 and 6165 is a missing sample.

  #6149 (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 3 blood samples. Mother is #1707 and father is #5822. 1707 and 5822 have an offspring in Plate 53: 6147 (F). Is this 6147 (F)? and then is 6147 actually 5517 (F, also on Plate 53)?


# Subset the SexMismatched data frame where DuplicateSample is FALSE
SexMismatchesToResolve <- SexMismatchesToResolve %>%
  filter(DuplicateSample == FALSE)

# Correct sex mismatches
SexMismatchesToResolve <- SexMismatchesToResolve %>%
  mutate(BirdIDConsensus = case_when(
    BirdID == 1617 ~ 1617,  # coverage too low probably to get correct sex
    BirdID == 3088 ~ 5145,  # (M, but geno F) Mother is #1716 and father is #1774, which is the masterbayes parents of 5145.
    BirdID == 5145 ~ 3088,  # (F, but geno M) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 2 blood samples. Mother is #1429 and father is #1886, which is the masterbayes parents of 3088
    BirdID == 5833 ~ 5833,  # coverage too low probably to get correct sex
    BirdID == 6156 ~ 6160,  # Masterbayes parents
    BirdID == 6160 ~ 5585,  # Sex mismatch female, geno male. Mother is 5164 and father is 2966, which is masterbayes parents of 5585 (sex mismatch male, geno female and missing sample)
    BirdID == 6166 ~ 5546,  # 6166 is male but geno Female, and mother is 4936 and father is 1731, who is masterbayes parents of 5546
    BirdID == 6141 ~ 6141,  # coverage too low probably to get correct sex
    BirdID == 5554 ~ 5511, # (M, but geno F) mismatched parents and also is a sequoia mother to #5773 and #6034, both times replacing #5111. Has 3 blood samples. Mother is #4863 and father is #1762. Related to 5634, 1884, 511, 5553, 1762 > 0.4. Gets assigned female in pre-deduplicated sequoia pedigree and gets assigned male in deduplicated sequoia pedigree. 
    BirdID == 5555 ~ 5512, # Sex mismatched male, but geno female. Mother is 3500 and father is 1762, which is the masterbayes parents of 5512 (Female, but geno male by 2/3 methods). 5555 is 5512, 5512 is 6151 (male), 6151 is 6178 (male), 6178 is 6176 (6176 is a missing sample, male)
  BirdID == 5827 ~ 5831, # (F, but geno M) never had offspring (mother only is mismatched)- check how it was sexed in database. Has 1 blood sample as FL. Mother is #3086. Related to 3086, 5339, 5598 > 0.35. 3086 has one offspring in Plate 53: 5831 (M). 5831 is 5563.
  BirdID == 6049 ~ 6165, # (M, but geno F) never had offspring (parents only are mismatched)- check how it was sexed in database. Has 3 blood samples. Father is #1750, who is masterbayes father of 6165 and 6165 is a female and a missing sample.
  BirdID == 6149 ~ 6147, # (M, but geno F) never had offspring (parents only are mismatched). Has 3 blood samples. Mother is #1707 and father is #5822, who are masterbayes parents of 6147. 1707 and 5822 have an offspring in Plate 53: 6147 (F). 5541 is 6149, 6149 is 6147, 6147 is 5517. But 5517 is unknown.
  BirdID == 1668 ~ 1668, # Sexing is incorrect, only one blood sample from 7/24/2002 and conflicts with behavioural method.
  BirdID == 5517  ~ 5836,   # (F, but geno M) never has offspring according to sequoia, and gets replaced by #329 (#1176) as father to #1176. Has 2 blood samples. BrF from 1996-2002.
  BirdID == 774 ~ NA,  # 2 blood samples, and BrF in many years
  BirdID == 1229 ~ NA,  # 2 blood samples for 1 FL, and pedigree mum has masterbayes sequoia conflict. It is likely this bird got mixed up.
  BirdID == 1435 ~ NA,  # 4 blood samples, and pedigree mum has masterbayes sequoia conflict.
  BirdID == 1676 ~ NA,  # 1 blood sample, and pedigree mum has masterbayes sequoia conflict.
  BirdID == 1668 ~ 1668,  # (M but geno F) Sexing is incorrect, only one blood sample from 7/24/2002 and conflicts with behavioural method but sequoia mum matches masterbayes mum
  #BirdID == 4893 ~ 4893, #(F, but geno M) CHD gene sexing is incorrect, only one blood sample from 2006. Masyerbayes mum matches sequoia mum. Now it gets picked up in new model.
  TRUE ~ NA_real_         # If no condition is met, set BirdIDConsensus to NA (numeric NA)
  ))

PedigreeMismatch <- PedigreeMismatch %>%
  mutate(BirdIDConsensus = case_when(
    #id == 5512  ~ 6151,   # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 5541 ~ 6149,  # Mother is 1852 and father is 4890, which is the masterbayes parents of 6149. 5541 is 6149, 6149 is 6147, 6147 is 5517. But 5517 is unknown. get correct sex
    #id == 5552 ~ 6151,  # 5552 (Female, but Male by 2/3 methods) and 6151 is Male. Mother is 4958 and father is 1710, which is masterbayes parents of 6151
    id == 5562 ~ 5534,  # Female matched. Mother is 2963 and father is 3089, which is masterbayes parents of 5534 (F). 5534 is 6145.
    id == 5831 ~ 5563,  # Male matched. Mother is 3604 and father is 5518, which is masterbayes parents of 5563 (M and a missing sample)
    id == 5832 ~ 5562,  # Female matched. Mother is 1605 and father is 4939, which is masterbayes parents of 5562 (F). 5562 is 6145, 6145 is a missing sample.
    id == 6151 ~ 6178,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6160 ~ 5585,  # Sex mismatch female, geno male. Mother is 5164 and father is 2966, which is masterbayes parents of 5585 (sex mismatch male, geno female and missing sample)
    #id == 6178 ~ 6176,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6147 ~ 5517, # Replaces 5517 as mother to 6668, who has father 5837 that masterbayes and sequoia agrees with
    id == 5511 ~ 6150, # probably is 6150 (Female), genomic father is 3456, I searched for 3456's offsprings and found 2 individuals overlaped with samples in plate 53, 6136 and 6150, 6136 was be identified and is Male, so I guess is 6150
    id == 5534 ~ 6145, # Female matches. Mother is 5514, who is 6145's mother in masterbayes. 5534 also replaces 6145 as maserbayes mother. 6145 is female and a missing sample
    id == 5687 ~ 5538, # 5687 (male) sequoia parents are 3567 and 1604 which is the masterbayes parents of 5538 (male)
    id == 5538 ~ 6166, # 5781 father is 5586 and this is the sequoia father of 6140, which is currently missing a sample
    TRUE ~ NA_real_         # If no condition is met, set BirdIDConsensus to NA (numeric NA)
  ))
PedigreeMismatch <- PedigreeMismatch %>%
  bind_rows(as_tibble(setNames(list(
    "5538", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 6166
  ), names(PedigreeMismatch))))



TestPedigreeMismatchSubset <- TestPedigreeMismatchSubset %>%
  mutate(BirdIDConsensus = case_when(
    #id == 5512  ~ 6151,   # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 5541 ~ 6149,  # Mother is 1852 and father is 4890, which is the masterbayes parents of 6149. 5541 is 6149, 6149 is 6147, 6147 is 5517. But 5517 is unknown. get correct sex
    #id == 5552 ~ 6151,  # 5552 (Female, but Male by 2/3 methods) and 6151 is Male. Mother is 4958 and father is 1710, which is masterbayes parents of 6151
    id == 5562 ~ 5534,  # Female matched. Mother is 2963 and father is 3089, which is masterbayes parents of 5534 (F). 5534 is 6145.
    id == 5831 ~ 5563,  # Male matched. Mother is 3604 and father is 5518, which is masterbayes parents of 5563 (M and a missing sample)
    id == 5832 ~ 5562,  # Female matched. Mother is 1605 and father is 4939, which is masterbayes parents of 5562 (F). 5562 is 6145, 6145 is a missing sample.
    id == 6151 ~ 6178,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6160 ~ 5585,  # Sex mismatch female, geno male. Mother is 5164 and father is 2966, which is masterbayes parents of 5585 (sex mismatch male, geno female and missing sample)
    #id == 6178 ~ 6176,  # 5555 is 5512, 5512 is 6151, 6151 is 6178, 6178 is 6176 (6176 is a missing sample)
    id == 6147 ~ 5517, # Replaces 5517 as mother to 6668, who has father 5837 that masterbayes and sequoia agrees with
    id == 5511 ~ 6150, # probably is 6150 (Female), genomic father is 3456, I searched for 3456's offsprings and found 2 individuals overlaped with samples in plate 53, 6136 and 6150, 6136 was be identified and is Male, so I guess is 6150
    id == 5534 ~ 6145, # Female matches. Mother is 5514, who is 6145's mother in masterbayes. 5534 also replaces 6145 as maserbayes mother. 6145 is female and a missing sample
    id == 5687 ~ 5538, # 5687 (male) sequoia parents are 3567 and 1604 which is the masterbayes parents of 5538 (male)
    id == 5538 ~ 6166, # 5781 father is 5586 and this is the sequoia father of 6140, which is currently missing a sample
    TRUE ~ NA_real_         # If no condition is met, set BirdIDConsensus to NA (numeric NA)
  ))
TestPedigreeMismatchSubset <- TestPedigreeMismatchSubset %>%
  bind_rows(as_tibble(setNames(list(
    "5538", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,NA, NA, NA, 6166
  ), names(PedigreeMismatch))))

# Initialize the new columns with FALSE
IdentifiersPlate53$Duplicate <- FALSE
IdentifiersPlate53$SexMismatches <- FALSE
IdentifiersPlate53$ParentsMismatched <- FALSE

# Check for matches between BirdID and BirdID1 or BirdID2 in UnintentionalDuplicatesMoreInfo
IdentifiersPlate53$Duplicate <- IdentifiersPlate53$BirdID %in% c(UnintentionalDuplicatesMoreInfo$BirdID1, UnintentionalDuplicatesMoreInfo$BirdID2)

# Check for matches between BirdID and BirdID in SexMismatched
IdentifiersPlate53$SexMismatches <- IdentifiersPlate53$BirdID %in% SexMismatchesToResolve$BirdID


# Check for matches between BirdID and id in PedigreeMismatch
IdentifiersPlate53$ParentsMismatched <- IdentifiersPlate53$BirdID %in% PedigreeMismatch$id

# Initialize the new column in IdentifiersPlate53
IdentifiersPlate53$BirdIDConsensus <- NA

# For UnintentionalDuplicatesMoreInfo (matching BirdID to BirdID1 or BirdID2)
for (i in 1:nrow(IdentifiersPlate53)) {
  bird_id <- IdentifiersPlate53$BirdID[i]
  
  # Check if BirdID matches either BirdID1 or BirdID2 in UnintentionalDuplicatesMoreInfo
  match_duplicate1 <- UnintentionalDuplicatesMoreInfo$BirdID1 == bird_id
  match_duplicate2 <- UnintentionalDuplicatesMoreInfo$BirdID2 == bird_id
  match_duplicate <- match_duplicate1 | match_duplicate2
  
  # If matched and BirdIDConsensus is not NA, assign it to IdentifiersPlate53$BirdIDConsensus
  if (any(match_duplicate)) {
    consensus_value <- UnintentionalDuplicatesMoreInfo$BirdIDConsensus[match_duplicate]
    if (length(consensus_value) == 1 && !is.na(consensus_value)) {
      IdentifiersPlate53$BirdIDConsensus[i] <- consensus_value
    }
  }
}

# For SexMismatched (matching BirdID to BirdID)
for (i in 1:nrow(IdentifiersPlate53)) {
  bird_id <- IdentifiersPlate53$BirdID[i]
  
  # Check if BirdID matches BirdID in SexMismatched
  match_sex_mismatch <- SexMismatchesToResolve$BirdID == bird_id
  if (any(match_sex_mismatch)) {
    consensus_value <- SexMismatchesToResolve$BirdIDConsensus[match_sex_mismatch]
    if (length(consensus_value) == 1 && !is.na(consensus_value)) {
      IdentifiersPlate53$BirdIDConsensus[i] <- consensus_value
    }
  }
}


# For PedigreeMismatch (matching BirdID to id)
for (i in 1:nrow(IdentifiersPlate53)) {
  bird_id <- IdentifiersPlate53$BirdID[i]
  
  # Check if BirdID matches id in PedigreeMismatch
  match_parents_mismatch <- PedigreeMismatch$id == bird_id
  if (any(match_parents_mismatch)) {
    consensus_value <- PedigreeMismatch$BirdIDConsensus[match_parents_mismatch]
    if (length(consensus_value) == 1 && !is.na(consensus_value)) {
      IdentifiersPlate53$BirdIDConsensus[i] <- consensus_value
    }
  }
}

openxlsx::write.xlsx(IdentifiersPlate53, file ="Plate53.xlsx", quote=FALSE)
getwd()

# Of the duplicate pair samples, exclude the sample with poorer coverage
Seychelles_warbler_traits <- SequencedIndividualsBirdIDsExtraDeduplicated %>%
  filter(!BirdID %in% UnintentionalDuplicates$BirdIDtoExclude)

# Exclude rows where we can't verify the sample because it is sex mismatched
Seychelles_warbler_traits <- Seychelles_warbler_traits %>%
  filter(!(BirdID %in% SexMismatchesToResolve$BirdID & 
           is.na(SexMismatchesToResolve$BirdIDConsensus[match(BirdID, SexMismatchesToResolve$BirdID)])))

# Exclude rows where we can't verify the sample because it is on Plate 53 and pedigree mismatched
Seychelles_warbler_traits <- Seychelles_warbler_traits %>%
  filter(!(BirdID %in% IdentifiersPlate53$BirdID & 
           is.na(IdentifiersPlate53$BirdIDConsensus[match(BirdID, IdentifiersPlate53$BirdID)]) & 
           IdentifiersPlate53$ParentsMismatched[match(BirdID, IdentifiersPlate53$BirdID)] == TRUE))

#Correct the BirdIDs for duplicates, and mixups

Seychelles_warbler_traits$BirdIDConsensus <- NA
# Ensure the BirdIDConsensus column exists and initialize if necessary
if (!"BirdIDConsensus" %in% colnames(Seychelles_warbler_traits)) {
  Seychelles_warbler_traits$BirdIDConsensus <- NA  # Initialize it as NA if it doesn't exist
}

# Loop through the rows of Seychelles_warbler_traits
for (i in 1:nrow(Seychelles_warbler_traits)) {
  bird_id <- Seychelles_warbler_traits$BirdID[i]
  
  # Only proceed if BirdID is not NA
  if (!is.na(bird_id)) {
    
    # Step 2: Condition 1: Match with UnintentionalDuplicates$BirdID1 or UnintentionalDuplicates$BirdID2
    if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i])) {
      if (bird_id %in% UnintentionalDuplicates$BirdID1) {
        idx <- match(bird_id, UnintentionalDuplicates$BirdID1)
        Seychelles_warbler_traits$BirdIDConsensus[i] <- UnintentionalDuplicates$BirdIDConsensus[idx]
      } else if (bird_id %in% UnintentionalDuplicates$BirdID2) {
        idx <- match(bird_id, UnintentionalDuplicates$BirdID2)
        Seychelles_warbler_traits$BirdIDConsensus[i] <- UnintentionalDuplicates$BirdIDConsensus[idx]
      }
    }

    # Step 3: Condition 2: Match with SexMismatchesToResolve$BirdID (only if BirdIDConsensus is still NA)
    if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i]) && bird_id %in% SexMismatchesToResolve$BirdID) {
      idx <- match(bird_id, SexMismatchesToResolve$BirdID)
      Seychelles_warbler_traits$BirdIDConsensus[i] <- SexMismatchesToResolve$BirdIDConsensus[idx]
    }

    # Step 4: Correct pedigree mismatched but sex matched samples
    if (is.na(Seychelles_warbler_traits$BirdIDConsensus[i]) && bird_id %in% TestPedigreeMismatchSubset$id) {
      idx <- match(bird_id, TestPedigreeMismatchSubset$id)  # Match BirdID with PedigreeMismatch
      Seychelles_warbler_traits$BirdIDConsensus[i] <- TestPedigreeMismatchSubset$BirdIDConsensus[idx]  # Assign BirdIDConsensus
    }
  }
  
  # Add a debug statement to track progress
  if (i %% 100 == 0) {
    cat("Processed ", i, " rows\n")
  }
}

# Step 5: Fill remaining NAs with the original BirdID if BirdIDConsensus is still empty
Seychelles_warbler_traits$BirdIDConsensus[is.na(Seychelles_warbler_traits$BirdIDConsensus)] <- Seychelles_warbler_traits$BirdID[is.na(Seychelles_warbler_traits$BirdIDConsensus)]


#Exclude pedigree mismatched birds on Plate 53
Seychelles_warbler_traits <- Seychelles_warbler_traits %>%
  filter(!BirdID %in% c(6178, 5781, 5787, 5836, 5512, 5552))

# Relink life-history
#Create life history data file
LifeHistoryData <- SequencedIndividualsBirdIDsExtraDeduplicated[, c("BirdID", "Sex","Lifespan","BirthYear","LastSeenYear","ReproductiveOutput")]

# Create genomic data 
GenomicData <- Seychelles_warbler_traits[, !colnames(Seychelles_warbler_traits) %in% c("BirdID", "Sex", "Lifespan", "BirthYear", "LastSeenYear", "ReproductiveOutput")]
GenomicData$BirdID <- GenomicData$BirdIDConsensus

# Merge life-history data with genomic data, corrected for sample ID
SeychellesWarblerTraitsCorrected <- merge(GenomicData, LifeHistoryData, by = "BirdID", all.x = TRUE)
SeychellesWarblerTraitsCorrected$LastSeenYear[is.na(SeychellesWarblerTraitsCorrected$LastSeenYear)] <- 
  SeychellesWarblerTraitsCorrected$DeathYear[is.na(SeychellesWarblerTraitsCorrected$LastSeenYear)]


duplicates <- SeychellesWarblerTraitsCorrected %>%
  filter(duplicated(BirdID) | duplicated(BirdID, fromLast = TRUE))

print(duplicates)

unique_duplicates <- SeychellesWarblerTraitsCorrected$BirdID[duplicated(SeychellesWarblerTraitsCorrected$BirdID)]
print(unique_duplicates)


# How does the genomic sexing plot look now?
#Run the sexing model and check any sex mismatches
#Build model 
logisticSexModelCorrected <- glm(Sex ~ cbind(Z_cov,(Coverage)) + cbind(nHet,nHom), 
                     data = subset(SeychellesWarblerTraitsCorrected,SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01) , 
                     family = "binomial")
#Assign sex based off model
predicted_probs <- predict(logisticSexModelCorrected, SeychellesWarblerTraitsCorrected, type = "response")
predicted_sex <- ifelse(predicted_probs > 0.5, "1", "0")

# Add the predicted sex to the data
SeychellesWarblerTraitsCorrected$PredictedSex <- predicted_sex

# Identify rows where CHD gene sex does not match the predicted sex
SexMismatchesCorrected <- SeychellesWarblerTraitsCorrected[SeychellesWarblerTraitsCorrected$Sex != SeychellesWarblerTraitsCorrected$PredictedSex, ]


# Create the plot with geom_text_repel to prevent label overlap
ggplot(subset(SeychellesWarblerTraitsCorrected, SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01), aes(x = Z_cov/Coverage, y = Het, color = as.factor(Sex))) +
  geom_point() +  # Scatter plot of the data
  labs(x = "Z coverage", y = "Het", title = "Proportional Z Chr. Coverage by Z Chr Heterozygosity") +
  theme_minimal() +  # Minimal theme
  scale_color_manual(values = c("red", "blue")) +  # Color for sexes
  geom_text_repel(data = subset(SexMismatchesCorrected,SexMismatchesCorrected$ProportionalZCoverage<0.01) , 
                  aes(x = ProportionalZCoverage, y = Het, label = BirdID), 
                  color = "black", 
                  size = 4,  # Adjust label size
                  box.padding = 0.5,  # Space between label and point
                  max.overlaps = 50,  # Limit the number of overlaps (e.g., 50 labels can overlap)
                  force = 2,  # Set force to avoid excessive movement of labels
                  max.iter = 1000,  # Limit number of iterations for adjusting the labels
                  segment.size = 0.5) +  # Adjust the segment size connecting the labels
  xlim(min(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) - 0, max(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) + 0) +  # Adjust plot limits
  ylim(min(SeychellesWarblerTraitsCorrected$Het) - 0, max(SeychellesWarblerTraitsCorrected$Het) + 0)  # Adjust plot limits

#The model picks up 1668 (M but geno F) with only one blood sample from 7/24/2002 and conflicts with behavioral method but sequoia mum matches masterbayes mum, so we change sex to F. The bird has no offspring.
#The model does not pick up 4893 well, but we can see from the plot that it should be change to Male as sequoia mum matches the masterbayes mum. the bird has no offspring.
LifeHistoryData <- LifeHistoryData %>%
  mutate(Sex = as.numeric(as.character(Sex)),  # Convert factor to numeric
         Sex = case_when(
           BirdID == 1668 ~ 0,   # Set Sex to 0 for BirdID 1668
           BirdID == 4893 ~ 1,   # Set Sex to 1 for BirdID 4893
           TRUE ~ Sex            # Keep original value for other rows
         ))

# Re-merge life-history data with genomic data, corrected for sample ID
SeychellesWarblerTraitsCorrected <- merge(GenomicData, LifeHistoryData, by = "BirdID", all.x = TRUE)

# How does the genomic sexing plot look now?
#Run the sexing model and check any sex mismatches
#Build model 
logisticSexModelCorrected <- glm(Sex ~ ProportionalZCoverage * WProportionMissing +nHet,
                      data = SexPrediction,
                      family = "binomial")
#Assign sex based off model
predicted_probs <- predict(logisticSexModelCorrected, SeychellesWarblerTraitsCorrected, type = "response")
predicted_sex <- ifelse(predicted_probs > 0.5, "1", "0")

# Add the predicted sex to the data
SeychellesWarblerTraitsCorrected$PredictedSex <- predicted_sex

# Identify rows where CHD gene sex does not match the predicted sex
SexMismatchesCorrected <- SeychellesWarblerTraitsCorrected[SeychellesWarblerTraitsCorrected$Sex != SeychellesWarblerTraitsCorrected$PredictedSex, ]

# Create the plot with geom_text_repel to prevent label overlap
ggplot(subset(SeychellesWarblerTraitsCorrected, SeychellesWarblerTraitsCorrected$ProportionalZCoverage<0.01), aes(x = Z_cov/Coverage, y = Het, color = as.factor(Sex))) +
  geom_point() +  # Scatter plot of the data
  labs(x = "Z coverage", y = "Het", title = "Proportional Z Chr. Coverage by Z Chr Heterozygosity") +
  theme_minimal() +  # Minimal theme
  scale_color_manual(values = c("red", "blue")) +  # Color for sexes
  xlim(min(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) - 0, max(SeychellesWarblerTraitsCorrected$ProportionalZCoverage) + 0) +  # Adjust plot limits
  ylim(min(SeychellesWarblerTraitsCorrected$Het) - 0, max(SeychellesWarblerTraitsCorrected$Het) + 0)  # Adjust plot limits


#Output list of correct samples
DeduplicatedforSequoiaCorrect<-data.frame(rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$Filepath)
write.table(DeduplicatedforSequoiaCorrect, file = "DeduplicatedforSequoiaCorrect.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Rename samples for sequioa to BirdIDs
RenameforSequoiaCorrected<-data.frame(rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$Filepath,rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$BirdID)

write.table(RenameforSequoiaCorrected, file = "RenameforSequoiaCorrected.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)


sw_GenoM_family_corrected <- GenoConvert(InFile = "reimputedinputfile_for_sequoia_corrected.raw", InFormat="raw")

lifehistcorrected <- lifehist %>%
  mutate(Sex = as.numeric(as.character(Sex)),  # Convert factor to numeric
         Sex = case_when(
           BirdID == 1668 ~ 0,   # Set Sex to 0 for BirdID 1668
           BirdID == 4893 ~ 1,   # Set Sex to 1 for BirdID 4893
           TRUE ~ Sex            # Keep original value for other rows
         ))


# Just parentage assignment (Module = "par"). 
sw_family_sequoia_justparents_corrected <- sequoia(GenoM = sw_GenoM_family_corrected, LifeHistData = lifehistcorrected, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

sw_family_pedigree_justparents_corrected_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents_corrected$Pedigree, Plot=TRUE, Symmetrical = TRUE)


openxlsx::write.xlsx(sw_family_sequoia_justparents_corrected[["PedigreePar"]], file ="PedigreeCorrected.xlsx", quote=FALSE)

masterpedconfident <- read.csv("pedFINAL_var124567_combined_unique_20230413.csv")
names(masterpedconfident)[names(masterpedconfident) == 'dad'] <- 'sire'
names(masterpedconfident)[names(masterpedconfident) == 'mum'] <- 'dam'
masterpedconfident<-subset(masterpedconfident, masterpedconfident$p>0.8)
masterpedconfident <- masterpedconfident[-c(4)]

sw_family_pedigree_justparents_corrected_comparison <- PedCompare(masterpedconfident[,c("id", "dam", "sire")], sw_family_sequoia_justparents_corrected$Pedigree, Plot=TRUE, Symmetrical = TRUE)

PedigreeMismatchConfident<-sw_family_pedigree_justparents_corrected_comparison[["Mismatch"]]

BirthDate$BirdID<-as.character(BirthDate$BirdID)
PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(BirthDate %>% select(BirdID, BirthDate), 
            by = c("id" = "BirdID")) %>%
  mutate(OffspringBirthYear = year(BirthDate))

PedigreeMismatchConfident$MasterbayesMaternalAge <- PedigreeMismatchConfident$OffspringBirthYear -
  year(BirthDate$BirthDate[match(PedigreeMismatchConfident$dam.1, BirthDate$BirdID)])

PedigreeMismatchConfident$SequoiaMaternalAge <- PedigreeMismatchConfident$OffspringBirthYear -
  year(BirthDate$BirthDate[match(PedigreeMismatchConfident$dam.2, BirthDate$BirdID)])

PedigreeMismatchConfident$MasterbayesPaternalAge <- PedigreeMismatchConfident$OffspringBirthYear -
  year(BirthDate$BirthDate[match(PedigreeMismatchConfident$sire.1, BirthDate$BirdID)])

PedigreeMismatchConfident$SequoiaPaternalAge <- PedigreeMismatchConfident$OffspringBirthYear -
  year(BirthDate$BirthDate[match(PedigreeMismatchConfident$sire.2, BirthDate$BirdID)])

#NA OffspringNatalTerrritory indicates we can't reliably assign natal territory
BirdIDSexYear$BirdID<-as.character(BirdIDSexYear$BirdID)
PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "CH" | !any(Status == "CH")) %>%  # Prioritize 'CH' if available
      select(BirdID, Year, TerritoryID),  
    by = c("id" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(OffspringNatalTerritory = TerritoryID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrF" | !any(Status == "BrF")) %>%  # Prioritize 'BrF' if available
      select(BirdID, Year, TerritoryID),  
    by = c("dam.1" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(MasterbayesMaternalTerritory = TerritoryID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrF" | !any(Status == "BrF")) %>%  # Prioritize 'BrF' if available
      select(BirdID, Year, TerritoryID),  
    by = c("dam.2" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(SequoiaMaternalTerritory = TerritoryID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrM" | !any(Status == "BrM")) %>%  # Prioritize 'BrM' if available
      select(BirdID, Year, TerritoryID),  
    by = c("sire.1" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(MasterbayesPaternalTerritory = TerritoryID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrM" | !any(Status == "BrM")) %>%  # Prioritize 'BrM' if available
      select(BirdID, Year, TerritoryID),  
    by = c("sire.2" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(SequoiaPaternalTerritory = TerritoryID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "CH" | !any(Status == "CH")) %>%  # Prioritize 'CH' if available
      select(BirdID, Year, BreedGroupID),  
    by = c("id" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(OffspringNatalBreedGroup = BreedGroupID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrF" | !any(Status == "BrF")) %>%  # Prioritize 'BrF' if available
      select(BirdID, Year, BreedGroupID),  
    by = c("dam.1" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(MasterbayesMaternalBreedGroup = BreedGroupID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrF" | !any(Status == "BrF")) %>%  # Prioritize 'BrF' if available
      select(BirdID, Year, BreedGroupID),  
    by = c("dam.2" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(SequoiaMaternalBreedGroup = BreedGroupID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrM" | !any(Status == "BrM")) %>%  # Prioritize 'BrM' if available
      select(BirdID, Year, BreedGroupID),  
    by = c("sire.1" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(MasterbayesPaternalBreedGroup = BreedGroupID)

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(
    BirdIDSexYear %>%
      group_by(BirdID, Year) %>%
      filter(PeriodStart == min(PeriodStart, na.rm = TRUE)) %>%
      filter(Status == "BrM" | !any(Status == "BrM")) %>%  # Prioritize 'BrM' if available
      select(BirdID, Year, BreedGroupID),  
    by = c("sire.2" = "BirdID", "OffspringBirthYear" = "Year")
  ) %>%
  rename(SequoiaPaternalBreedGroup = BreedGroupID)

PedigreeCorrected<-read_xlsx("PedigreeCorrected.xlsx")

Rel.snp<- read.table("Corrected572.grm", stringsAsFactors = FALSE)
Rel.id <- read.table("Corrected572.grm.id", stringsAsFactors=FALSE)
Rped.new<-CalcRped(sw_family_sequoia_justparents_corrected[["PedigreePar"]], OUT = "DF")
#Rel.id<-merge(Rel.id, RenameforSequoiaCorrected, by.x='V2', by.y='SeychellesWarblerTraitsCorrected.Filepath') %>% select(V1,SeychellesWarblerTraitsCorrected.BirdID)
Rel.snp[,1] <- as.character(factor(Rel.snp[,1], labels=Rel.id[,2]))
Rel.snp[,2] <- as.character(factor(Rel.snp[,2], labels=Rel.id[,2]))
names(Rel.snp) <- c("IID1", "IID2", "nSNPS", "R.GRM")
Rel.snp <- Rel.snp[Rel.snp$IID1 != Rel.snp$IID2,] 

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID1", "dam.1" = "IID2")) %>%  # Match id with IID1 and dam.1 with IID2
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID2", "dam.1" = "IID1")) %>%  # Match id with IID2 and dam.1 with IID1
  mutate(
    MasterbayesMaternalRelatedness = coalesce(R.GRM.x, R.GRM.y)  # Use coalesce to select the non-NA value
  ) %>%
  select(-R.GRM.x, -R.GRM.y)  # Clean up the temporary R.GRM columns


PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID1", "dam.2" = "IID2")) %>%  # Match id with IID1 and dam.2 with IID2
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID2", "dam.2" = "IID1")) %>%  # Match id with IID2 and dam.2 with IID1
  mutate(
    SequoiaMaternalRelatedness = coalesce(R.GRM.x, R.GRM.y)  # Use coalesce to select the non-NA value
  ) %>%
  select(-R.GRM.x, -R.GRM.y)  # Clean up the temporary R.GRM columns

PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID1", "sire.1" = "IID2")) %>%  # Match id with IID1 and sire.1 with IID2
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID2", "sire.1" = "IID1")) %>%  # Match id with IID2 and sire.1 with IID1
  mutate(
    MasterbayesPaternalRelatedness = coalesce(R.GRM.x, R.GRM.y)  # Use coalesce to select the non-NA value
  ) %>%
  select(-R.GRM.x, -R.GRM.y)  # Clean up the temporary R.GRM columns


PedigreeMismatchConfident <- PedigreeMismatchConfident %>%
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID1", "sire.2" = "IID2")) %>%  # Match id with IID1 and sire.2 with IID2
  left_join(Rel.snp %>%
              select(IID1, IID2, R.GRM), 
            by = c("id" = "IID2", "sire.2" = "IID1")) %>%  # Match id with IID2 and sire.2 with IID1
  mutate(
    SequoiaPaternalRelatedness = coalesce(R.GRM.x, R.GRM.y)  # Use coalesce to select the non-NA value
  ) %>%
  select(-R.GRM.x, -R.GRM.y)  # Clean up the temporary R.GRM columns

n_distinct(PedigreeMismatchConfident$id)

openxlsx::write.xlsx(PedigreeMismatchConfident, file ="PedigreeMismatchesCorrectedMasyerbayesConfidentExtra.xlsx", quote=FALSE)

openxlsx::write.xlsx(sw_family_pedigree_justparents_corrected_comparison[["Mismatch"]], file ="PedigreeMismatchesCorrectedMasyerbayesConfident.xlsx", quote=FALSE)

#One final iteration of pedigree assignment on this *final* cleaned dataset as sample BirdID 775 is in fact BirdID 469 because they both come from the same BloodTubeNumber. This was identified when comparing sequoia and masterbayes parent assignments.
SeychellesWarblerTraitsCorrected <- SeychellesWarblerTraitsCorrected[SeychellesWarblerTraitsCorrected$BirdID != 469, ]
SeychellesWarblerTraitsCorrected$BirdID[SeychellesWarblerTraitsCorrected$BirdID == 775] <- 469
SeychellesWarblerTraitsCorrected$BirdIDConsensus[SeychellesWarblerTraitsCorrected$BirdIDConsensus == 775] <- 469

DeduplicatedforSequoiaCorrect<-data.frame(rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$Filepath)
write.table(DeduplicatedforSequoiaCorrect, file = "DeduplicatedforSequoiaCorrect.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

#Rename samples for sequioa to BirdIDs
RenameforSequoiaCorrected<-data.frame(rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$Filepath,rep("0",length(SeychellesWarblerTraitsCorrected$Filepath)),SeychellesWarblerTraitsCorrected$BirdID)

write.table(RenameforSequoiaCorrected, file = "RenameforSequoiaCorrected.txt", sep = "\t",
            col.names = F, row.names = F, quote = FALSE)

sw_GenoM_family_corrected <- GenoConvert(InFile = "reimputedinputfile_for_sequoia_corrected.raw", InFormat="raw")

sw_family_sequoia_justparents_corrected <- sequoia(GenoM = sw_GenoM_family_corrected, LifeHistData = lifehistcorrected, Module = "par", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))

sw_family_pedigree_justparents_corrected_comparison <- PedCompare(masterped[,c("id", "dam", "sire")], sw_family_sequoia_justparents_corrected$Pedigree, Plot=TRUE, Symmetrical = TRUE)
sw_family_pedigree_justparents_corrected_comparison <- PedCompare(masterpedconfident[,c("id", "dam", "sire")], sw_family_sequoia_justparents_corrected$Pedigree, Plot=TRUE, Symmetrical = TRUE)

openxlsx::write.xlsx(sw_family_sequoia_justparents_corrected[["PedigreePar"]], file ="PedigreeCorrected.xlsx", quote=FALSE)

#sw_family_sequoia_full_corrected <- sequoia(GenoM = sw_GenoM_family_corrected, LifeHistData = lifehistcorrected, Module = "ped", quiet="verbose", args.AP = list(MaxAgeParent = c(19)))
#SummarySeq(sw_family_sequoia_full_corrected)


## Why are not all individuals assigned in sequoia? ##

# Summary statistics function
summarize_birth_dates <- function(data) {
  summary_stats <- data.frame(
    Mean = mean(data$OffspringBirthDate, na.rm = TRUE),
    SD = sd(data$OffspringBirthDate, na.rm = TRUE),
    Min = min(data$OffspringBirthDate, na.rm = TRUE),
    Max = max(data$OffspringBirthDate, na.rm = TRUE),
    IQR = IQR(data$OffspringBirthDate, na.rm = TRUE)
  )
  return(summary_stats)
}

# Subset where both dam and sire are NA
SequoiaPedigree<-(sw_family_pedigree_justparents_corrected_comparison[["ConsensusPed"]])
SequoiaPedigree <- SequoiaPedigree %>%
  rename(dam = dam.c) %>%
  rename(sire = sire.c)
BirthDate$BirdID<-as.character(BirthDate$BirdID)

SequoiaPedigree <- SequoiaPedigree %>%
  left_join(BirthDate, by = c("id" = "BirdID")) %>%
  rename(OffspringBirthDate = BirthDate)  # Renaming for clarity

SequoiaPedigree <- SequoiaPedigree %>%
  left_join(BirthDate, by = c("dam" = "BirdID")) %>%
  rename(DamBirthDate = BirthDate)  # Renaming for clarity

SequoiaPedigree <- SequoiaPedigree %>%
  mutate(
    MaternalAge = as.numeric(difftime(OffspringBirthDate, DamBirthDate, units = "weeks")) / 52.25  # Convert weeks to years
  )
filtered_data_bothparents <- SequoiaPedigree[!is.na(SequoiaPedigree$dam) & !is.na(SequoiaPedigree$sire), ]
filtered_data_bothparentsmissing <- SequoiaPedigree[is.na(SequoiaPedigree$dam) & is.na(SequoiaPedigree$sire), ]
filtered_data_oneparentmissing <- SequoiaPedigree[is.na(SequoiaPedigree$dam) | is.na(SequoiaPedigree$sire), ]


# Compute summary statistics
filtered_data_bothparents <- summarize_birth_dates(filtered_data_bothparents)
filtered_data_bothparentsmissing <- summarize_birth_dates(filtered_data_bothparentsmissing)
filtered_data_oneparentmissing <- summarize_birth_dates(filtered_data_oneparentmissing)


# Print results
print("Summary of OffspringBirthDate for the entire dataset:")
print(filtered_data_bothparents)

print("Summary of OffspringBirthDate for individuals with unknown parents:")
print(filtered_data_oneparentmissing)

print("Summary of OffspringBirthDate for individuals with unknown parents:")
print(filtered_data_bothparentsmissing)

openxlsx::write.xlsx(SeychellesWarblerTraitsCorrected, file ="SeychellesWarblerTraitsCorrected.xlsx", quote=FALSE)

openxlsx::write.xlsx(SequoiaPedigree, file ="SequoiaMasterbayesPedigree.xlsx", quote=FALSE)

```
## Ch.1 Relatedness comparison

Visualising performance of masterbayes and sequoia using pairwise relatedness

```{r relatedness_comparison, eval = TRUE, echo = TRUE, tidy=FALSE}


#Comparing genomic relatedness to masterbayes pedigree relatedness and to sequoia pedigree relatedness
Rped.old<-CalcRped(masterped, OUT="DF")
Rel.snp<- read.table("relatednesscorrected.grm", stringsAsFactors = FALSE)
Rel.id <- read.table("relatednesscorrected.grm.id", stringsAsFactors=FALSE)
#Rped.new<-CalcRped(as.data.frame(PedigreeCorrected), OUT = "DF")
Rped.new<-CalcRped(sw_family_sequoia_justparents_corrected[["PedigreePar"]], OUT = "DF")
#Rel.id<-merge(Rel.id, RenameforSequoiaCorrected, by.x='V2', by.y='SeychellesWarblerTraitsCorrected.Filepath') %>% select(V1,SeychellesWarblerTraitsCorrected.BirdID)
Rel.snp[,1] <- as.character(factor(Rel.snp[,1], labels=Rel.id[,2]))
Rel.snp[,2] <- as.character(factor(Rel.snp[,2], labels=Rel.id[,2]))
names(Rel.snp) <- c("IID1", "IID2", "nSNPS", "R.GRM")
Rel.snp <- Rel.snp[Rel.snp$IID1 != Rel.snp$IID2,] 

Rel.both.old <- merge(data.table(Rel.snp[,c(1,2,4)], key=c("IID1", "IID2")),
                  data.table(Rped.old, key=c("IID1", "IID2")), all.x=TRUE)

round(cor(Rel.both.old[, c("R.GRM","R.ped")],use="pairwise.complete"), 3)
hexbin::hexbinplot(Rel.both.old$R.ped ~ Rel.both.old$R.GRM,  # Swap x and y
                   xbins=100, aspect=1, 
                   xlim=c(-.7, 1.2), ylim=c(-0.05,1.2),  # Swap xlim and ylim
                   xlab="Genomic relatedness", ylab="Microsatellites pedigree relatedness",  # Update labels
                   trans=log10, inv=function(x) 10^x,
                   colorcut=seq(0,1,length=14), maxcnt=10^6.5,
                   colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')},
                   par.settings = list(axis.text = list(cex = 1.5),  # Increase tick label size
                                       par.xlab.text = list(cex = 2),  # Increase x-axis label size
                                       par.ylab.text = list(cex = 2)))  # Increase y-axis label size
#png("microsatellite_hexbin_plot_sequoia.png", width = 1200, height = 1000, res = 150) #for saving only 

hb <- hexbin::hexbin(Rel.both.old$R.ped ~ Rel.both.old$R.GRM,
                     xbins=100, xbnds=c(-.7, 1.2), ybnds=c(-.05, 1),
                     xlab="Genomic relatedness", ylab="Microsatellite pedigree relatedness")
hbp <- hexbin::plot(hb,
                                  trans=log10, inv=function(x) 10^x,
                                  colorcut=seq(0,1,length=14), maxcnt=10^6.5,
                                  colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')}
                                  ) 
hexbin::hexVP.abline(hbp$plot.vp, lm(Rel.both.old$R.GRM ~ Rel.both.old$R.ped))
#dev.off() #for saving only

rm(Rel.both.old)
Rel.both.new <- merge(data.table(Rel.snp[,c(1,2,4)], key=c("IID1", "IID2")),
                  data.table(Rped.new, key=c("IID1", "IID2")), all.x=TRUE)
round(cor(Rel.both.new[, c("R.GRM","R.ped")],use="pairwise.complete"), 3)
hexbin::hexbinplot(Rel.both.new$R.ped ~ Rel.both.new$R.GRM,  # Swap x and y
                   xbins=100, aspect=1, 
                   xlim=c(-.7, 1.2), ylim=c(-0.05,1.2),  # Swap xlim and ylim
                   xlab="Genomic relatedness", ylab="Sequoia pedigree relatedness",  # Update labels
                   trans=log10, inv=function(x) 10^x,
                   colorcut=seq(0,1,length=14), maxcnt=10^6.5,
                   colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')},
                   par.settings = list(axis.text = list(cex = 1.5),  # Increase tick label size
                                       par.xlab.text = list(cex = 2),  # Increase x-axis label size
                                       par.ylab.text = list(cex = 2)))  # Increase y-axis label size

#png("relatedness_hexbin_plot_sequoia.png", width = 1200, height = 1000, res = 150) #for saving only 

hb <- hexbin::hexbin(Rel.both.new$R.ped ~ Rel.both.new$R.GRM,
                     xbins=100, xbnds=c(-.7, 1.2), ybnds=c(-.05, 1),
                     xlab="Genomic relatedness", ylab="Sequoia pedigree relatedness")
hbp <- hexbin::plot(hb,
                                  trans=log10, inv=function(x) 10^x,
                                  colorcut=seq(0,1,length=14), maxcnt=10^6.5,
                                  colramp = function(n) {grDevices::hcl.colors(n, palette='Berlin')}
                                  ) 
hexbin::hexVP.abline(hbp$plot.vp, lm(Rel.both.new$R.GRM ~ Rel.both.new$R.ped))

#dev.off() #for saving only


```
## Ch.1 Mix-up flow diagram

Flow diagram to illustrate mix ups.
```{r flow_diagram, eval = TRUE, echo = TRUE, tidy=FALSE}
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

flowchart_dot_code <- "
digraph sample_flow {

  # --- Global Graph Attributes ---
  graph [rankdir = TB,
         splines = true,
         nodesep = 0.6,
         ranksep = 2,
         size = '10,15',
         outputorder = nodesfirst
         ];

  # --- Global Node Defaults ---
  node [fontname = Helvetica,
        fontsize = 112,
        shape = rectangle,
        fixedsize = false,
        width = 3.5,
        height = 1.2,
        penwidth = 2.5
       ];

  # --- Global Edge Defaults ---
  edge [fontname = Helvetica,
        fontsize = 100,
        arrowhead = normal,
        arrowsize=5,
        penwidth=3
       ];

  # --- Node Style Attributes ---
  # Remaining:  style = filled, fillcolor = '#4A6FB1', color = '#2C4C7F', fontcolor = white
  # Issue:      style = filled, fillcolor = '#F2A4A4', color = '#B35D5D', fontcolor = black
  # Retained:   style = filled, fillcolor = '#A2C8FF', color = '#79A6C1', fontcolor = black
  # Excluded:   style = filled, fillcolor = '#4B8BE8', color = '#3565A4', fontcolor = black

  # --- Key/Legend Nodes ---
  subgraph cluster_key {
    node [shape = box, height=0.5, width=0.5];

    key_title    [label = 'Key:', shape = plaintext, fontsize = 100];
    key_issue    [label = 'Issue Type', style=filled, fillcolor='#F2A4A4', color='#B35D5D', fontcolor=black];
    key_retained [label = 'Retained', style=filled, fillcolor='#A2C8FF', color='#79A6C1', fontcolor=black];
    key_excluded [label = 'Excluded', style=filled, fillcolor='#4B8BE8', color='#3565A4', fontcolor=black];
    key_remaining[label = 'Remaining', style=filled, fillcolor='#4A6FB1', color='#2C4C7F', fontcolor=white];

    key_title -> key_issue -> key_retained -> key_excluded -> key_remaining [style = invis];
  }

  # --- Define Main Flowchart Nodes (with styles applied directly) ---
  start [label = 'Initial Samples: 1,976', shape = oval, style = filled, fillcolor = '#4A6FB1', color = '#2C4C7F', fontcolor = white]
  issue2   [label = '(a) Duplicate\\n58 samples', style = filled, fillcolor = '#F2A4A4', color = '#B35D5D', fontcolor = black]
  retain2  [label = '29 Retained:\\nHigher coverage samples\\nof the duplicate pair', style = filled, fillcolor = '#A2C8FF', color = '#79A6C1', fontcolor = black]
  exclude2 [label = '29 Excluded:\\nLower coverage samples\\nof the duplicate pair', style = filled, fillcolor = '#4B8BE8', color = '#3565A4', fontcolor = black]
  remain2  [label = 'Remaining: 1,947', style = filled, fillcolor = '#4A6FB1', color = '#2C4C7F', fontcolor = white]
  issue3   [label = '(b) Sex mismatch\\n20 samples', style = filled, fillcolor = '#F2A4A4', color = '#B35D5D', fontcolor = black]
  retain3  [label = '13 Retained:\\n• 2 Re-assigned sex\\n(old and sampled once)\\n• 11 Re-assigned individual\\nby pedigree comparison*', style = filled, fillcolor = '#A2C8FF', color = '#79A6C1', fontcolor = black]
  exclude3 [label = '7 Excluded:\\nCHD-gene sexed multiple times\\nsuggesting wrong sample', style = filled, fillcolor = '#4B8BE8', color = '#3565A4', fontcolor = black]
  remain3  [label = 'Remaining: 1,940', style = filled, fillcolor = '#4A6FB1', color = '#2C4C7F', fontcolor = white]
  issue4   [label = '(c) Plate X\\n23 samples', style = filled, fillcolor = '#F2A4A4', color = '#B35D5D', fontcolor = black]
  retain4  [label = '18 Retained:\\n• 9 Pedigree comparison matched*\\n• 9 Re-assigned individual by pedigree comparison*', style = filled, fillcolor = '#A2C8FF', color = '#79A6C1', fontcolor = black]
  exclude4 [label = '5 Excluded:\\nInsufficient data\\nin pedigree comparison*', style = filled, fillcolor = '#4B8BE8', color = '#3565A4', fontcolor = black]
  remain4  [label = 'Remaining: 1,935', style = filled, fillcolor = '#4A6FB1', color = '#2C4C7F', fontcolor = white]
  issue5   [label = '(d) Tube number\\n1 sample', style = filled, fillcolor = '#F2A4A4', color = '#B35D5D', fontcolor = black]
  retain5  [label = '1 Retained:\\nRe-assigned individual by pedigree comparison*', style = filled, fillcolor = '#A2C8FF', color = '#79A6C1', fontcolor = black]
  exclude5 [label = '0 Excluded', style = filled, fillcolor = '#4B8BE8', color = '#3565A4', fontcolor = black]
  final    [label = 'Final Samples: 1,935', shape = oval, style = filled, fillcolor = '#4A6FB1', color = '#2C4C7F', fontcolor = white]

  # --- Edge Definitions (Connect the nodes) ---
  start -> issue2; issue2 -> retain2 ; issue2 -> exclude2 ; issue2 -> remain2;
  remain2 -> issue3; issue3 -> retain3 ; issue3 -> exclude3 ; issue3 -> remain3;
  remain3 -> issue4; issue4 -> retain4 ; issue4 -> exclude4 ; issue4 -> remain4;
  remain4 -> issue5; issue5 -> retain5 ; issue5 -> exclude5 ; issue5 -> final;

}" # End of DOT code string

# Render the diagram
sample_mixup_diagram <- grViz(flowchart_dot_code)

# Display the diagram
print(sample_mixup_diagram)

# --- Save as SVG ---
svg_filename <- "sample_mixup_flow_revised.svg"
export_svg(sample_mixup_diagram) %>%
  cat(file = svg_filename)

print(paste("Flowchart saved as SVG:", svg_filename))

png_filename <- "sample_mixup_flow_revised.png"

# Convert SVG to PNG
rsvg_png(
  svg = svg_filename,
  file = png_filename,
  width = 4000,   # Increase width for high resolution
  height = 6000   # Adjust height proportionally
)

# Confirm completion
cat("PNG saved as:", png_filename, "\n")




```

## Ch.1 Functional annotations

Script to link dataframes to make neater as provided by Chuen Zhang Lee.

```{r annotations, eval = FALSE, echo = TRUE}
# read in eggnog output
seywarbler <- read_tsv("out.emapper.decorated.gff",col_names = FALSE)
# give it column names
colnames(seywarbler) <- c("geneno", "source", "feature", "start", "end", "score",
                          "strand", "frame", "attribute")

# read in GALBA output (with chromosome positions)
seygalba <- read_csv("galba2.gff3.csv",col_names = FALSE)
colnames(seygalba) <- c("CHR_name","CHR_rag", "source", "feature", "start", "end", "score",
                        "strand", "frame", "attribute","geneno")

# read in chromosome names
seychrom <- read_csv("Chromosomenames_Chr.csv")

# merge chromosome names with galba - this give actual chromosome numbers as "CHR"
seychromgalba <- merge(seygalba,seychrom, by="CHR_name",all=T) %>% mutate(CHR = replace_na(CHR,"0"))

# merge eggNOG with updated GALBA - this gives actual gene annotations as "attribute.y"
seyall <- seywarbler %>% dplyr::select(geneno,source,attribute) %>% merge(seychromgalba,., by=c("geneno"),all=T)

# make it into proper .gff format to export
swgff <- seyall %>% mutate(source = "AUGUSTUS_eggNOGmapper") %>% dplyr::select(CHR,source,feature,start,end,score,strand,frame,attribute.x,attribute.y)
#write as tsv, can rename so it reads as .gff if wanted
#write_tsv(swgff,"~/Documents/PhD/R_analysis/Genomics/InputTables/sw_eggnog_gff.tsv")

# this is number of genes per chromsome. 
numberofgenesperchrom <- swgff %>% group_by(CHR) %>% summarise(n())
number_of_genes_per_chrom <- swgff %>%
  group_by(CHR) %>%
  summarise(number_of_genes = n()) %>%
  summarise(total_genes = sum(number_of_genes))
print(number_of_genes_per_chrom)
# for GWAS, use only features in "mRNA" and create a midpoint to find SNPs closest to the gene
seygenes <- seyall %>% filter(feature %in% "mRNA") %>% arrange(start,end) %>% mutate(mid = start + (end-start)/2) 
rm(swgff)
```

